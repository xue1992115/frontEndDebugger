{"version":3,"file":"kafka-reply-partition-assigner.js","sourceRoot":"","sources":["kafka-reply-partition-assigner.ts"],"names":[],"mappings":"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","sourcesContent":["import { loadPackage } from '@nestjs/common/utils/load-package.util';\nimport { isUndefined } from '@nestjs/common/utils/shared.utils';\nimport { ClientKafka } from '../client/client-kafka';\nimport {\n  Cluster,\n  GroupMember,\n  GroupMemberAssignment,\n  GroupState,\n  MemberMetadata,\n} from '../external/kafka.interface';\n\nlet kafkaPackage: any = {};\n\nexport class KafkaReplyPartitionAssigner {\n  readonly name = 'NestReplyPartitionAssigner';\n  readonly version = 1;\n\n  constructor(\n    private readonly clientKafka: ClientKafka,\n    private readonly config: {\n      cluster: Cluster;\n    },\n  ) {\n    kafkaPackage = loadPackage(\n      'kafkajs',\n      KafkaReplyPartitionAssigner.name,\n      () => require('kafkajs'),\n    );\n  }\n\n  /**\n   * This process can result in imbalanced assignments\n   * @param {array} members array of members, e.g: [{ memberId: 'test-5f93f5a3' }]\n   * @param {array} topics\n   * @param {Buffer} userData\n   * @returns {array} object partitions per topic per member\n   */\n  public async assign(group: {\n    members: GroupMember[];\n    topics: string[];\n  }): Promise<GroupMemberAssignment[]> {\n    const assignment = {};\n    const previousAssignment = {};\n\n    const membersCount = group.members.length;\n    const decodedMembers = group.members.map(member =>\n      this.decodeMember(member),\n    );\n    const sortedMemberIds = decodedMembers\n      .map(member => member.memberId)\n      .sort();\n\n    // build the previous assignment and an inverse map of topic > partition > memberId for lookup\n    decodedMembers.forEach(member => {\n      if (\n        !previousAssignment[member.memberId] &&\n        Object.keys(member.previousAssignment).length > 0\n      ) {\n        previousAssignment[member.memberId] = member.previousAssignment;\n      }\n    });\n\n    // build a collection of topics and partitions\n    const topicsPartitions = group.topics\n      .map(topic => {\n        const partitionMetadata =\n          this.config.cluster.findTopicPartitionMetadata(topic);\n        return partitionMetadata.map(m => {\n          return {\n            topic,\n            partitionId: m.partitionId,\n          };\n        });\n      })\n      .reduce((acc, val) => acc.concat(val), []);\n\n    // create the new assignment by populating the members with the first partition of the topics\n    sortedMemberIds.forEach(assignee => {\n      if (!assignment[assignee]) {\n        assignment[assignee] = {};\n      }\n\n      // add topics to each member\n      group.topics.forEach(topic => {\n        if (!assignment[assignee][topic]) {\n          assignment[assignee][topic] = [];\n        }\n\n        // see if the topic and partition belong to a previous assignment\n        if (\n          previousAssignment[assignee] &&\n          !isUndefined(previousAssignment[assignee][topic])\n        ) {\n          // take the minimum partition since replies will be sent to the minimum partition\n          const firstPartition = previousAssignment[assignee][topic];\n\n          // create the assignment with the first partition\n          assignment[assignee][topic].push(firstPartition);\n\n          // find and remove this topic and partition from the topicPartitions to be assigned later\n          const topicsPartitionsIndex = topicsPartitions.findIndex(\n            topicPartition => {\n              return (\n                topicPartition.topic === topic &&\n                topicPartition.partitionId === firstPartition\n              );\n            },\n          );\n\n          // only continue if we found a partition matching this topic\n          if (topicsPartitionsIndex !== -1) {\n            // remove inline\n            topicsPartitions.splice(topicsPartitionsIndex, 1);\n          }\n        }\n      });\n    });\n\n    // check for member topics that have a partition length of 0\n    sortedMemberIds.forEach(assignee => {\n      group.topics.forEach(topic => {\n        // only continue if there are no partitions for assignee's topic\n        if (assignment[assignee][topic].length === 0) {\n          // find the first partition for this topic\n          const topicsPartitionsIndex = topicsPartitions.findIndex(\n            topicPartition => {\n              return topicPartition.topic === topic;\n            },\n          );\n\n          if (topicsPartitionsIndex !== -1) {\n            // find and set the topic partition\n            const partition =\n              topicsPartitions[topicsPartitionsIndex].partitionId;\n\n            assignment[assignee][topic].push(partition);\n\n            // remove this partition from the topics partitions collection\n            topicsPartitions.splice(topicsPartitionsIndex, 1);\n          }\n        }\n      });\n    });\n\n    // then balance out the rest of the topic partitions across the members\n    const insertAssignmentsByTopic = (topicPartition, i) => {\n      const assignee = sortedMemberIds[i % membersCount];\n\n      assignment[assignee][topicPartition.topic].push(\n        topicPartition.partitionId,\n      );\n    };\n\n    // build the assignments\n    topicsPartitions.forEach(insertAssignmentsByTopic);\n\n    // encode the end result\n    return Object.keys(assignment).map(memberId => ({\n      memberId,\n      memberAssignment: kafkaPackage.AssignerProtocol.MemberAssignment.encode({\n        version: this.version,\n        assignment: assignment[memberId],\n      }),\n    }));\n  }\n\n  public protocol(subscription: {\n    topics: string[];\n    userData: Buffer;\n  }): GroupState {\n    const stringifiedUserData = JSON.stringify({\n      previousAssignment: this.getPreviousAssignment(),\n    });\n    subscription.userData = Buffer.from(stringifiedUserData);\n\n    return {\n      name: this.name,\n      metadata: kafkaPackage.AssignerProtocol.MemberMetadata.encode({\n        version: this.version,\n        topics: subscription.topics,\n        userData: subscription.userData,\n      }),\n    };\n  }\n\n  public getPreviousAssignment() {\n    return this.clientKafka.getConsumerAssignments();\n  }\n\n  public decodeMember(member: GroupMember) {\n    const memberMetadata = kafkaPackage.AssignerProtocol.MemberMetadata.decode(\n      member.memberMetadata,\n    ) as MemberMetadata;\n    const memberUserData = JSON.parse(memberMetadata.userData.toString());\n\n    return {\n      memberId: member.memberId,\n      previousAssignment: memberUserData.previousAssignment,\n    };\n  }\n}\n"]}