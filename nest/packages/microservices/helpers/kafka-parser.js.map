{"version":3,"file":"kafka-parser.js","sourceRoot":"","sources":["kafka-parser.ts"],"names":[],"mappings":";;;AAAA,oEAA0D;AAG1D,MAAa,WAAW;IAGtB,YAAY,MAA0B;QACpC,IAAI,CAAC,UAAU,GAAG,CAAC,MAAM,IAAI,MAAM,CAAC,UAAU,CAAC,IAAI,KAAK,CAAC;IAC3D,CAAC;IAEM,KAAK,CAAU,IAAS;QAC7B,4EAA4E;QAC5E,MAAM,MAAM,mCACP,IAAI,KACP,OAAO,oBAAO,IAAI,CAAC,OAAO,IAC3B,CAAC;QAEF,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YACpB,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACxC;QAED,IAAI,CAAC,IAAA,oBAAK,EAAC,IAAI,CAAC,GAAG,CAAC,EAAE;YACpB,MAAM,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;SACpC;QACD,IAAI,CAAC,IAAA,oBAAK,EAAC,IAAI,CAAC,OAAO,CAAC,EAAE;YACxB,MAAM,iBAAiB,GAAG,CAAC,GAAW,EAAE,EAAE;gBACxC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;YACvD,CAAC,CAAC;YACF,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,iBAAiB,CAAC,CAAC;SACtD;aAAM;YACL,MAAM,CAAC,OAAO,GAAG,EAAE,CAAC;SACrB;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAEM,MAAM,CAAC,KAAa;QACzB,IAAI,IAAA,oBAAK,EAAC,KAAK,CAAC,EAAE;YAChB,OAAO,IAAI,CAAC;SACb;QACD,qEAAqE;QACrE,uEAAuE;QACvE,IACE,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC;YACtB,KAAK,CAAC,MAAM,GAAG,CAAC;YAChB,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,EACxB;YACA,OAAO,KAAK,CAAC;SACd;QAED,IAAI,MAAM,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAC;QAC9B,MAAM,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QAEnC,uCAAuC;QACvC,IAAI,SAAS,KAAK,GAAG,IAAI,SAAS,KAAK,GAAG,EAAE;YAC1C,IAAI;gBACF,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,CAAC;aACvC;YAAC,OAAO,CAAC,EAAE,GAAE;SACf;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AAzDD,kCAyDC","sourcesContent":["import { isNil } from '@nestjs/common/utils/shared.utils';\nimport { KafkaParserConfig } from '../interfaces';\n\nexport class KafkaParser {\n  protected readonly keepBinary: boolean;\n\n  constructor(config?: KafkaParserConfig) {\n    this.keepBinary = (config && config.keepBinary) || false;\n  }\n\n  public parse<T = any>(data: any): T {\n    // Clone object to as modifying the original one would break KafkaJS retries\n    const result = {\n      ...data,\n      headers: { ...data.headers },\n    };\n\n    if (!this.keepBinary) {\n      result.value = this.decode(data.value);\n    }\n\n    if (!isNil(data.key)) {\n      result.key = this.decode(data.key);\n    }\n    if (!isNil(data.headers)) {\n      const decodeHeaderByKey = (key: string) => {\n        result.headers[key] = this.decode(data.headers[key]);\n      };\n      Object.keys(data.headers).forEach(decodeHeaderByKey);\n    } else {\n      result.headers = {};\n    }\n    return result;\n  }\n\n  public decode(value: Buffer): object | string | null | Buffer {\n    if (isNil(value)) {\n      return null;\n    }\n    // A value with the \"leading zero byte\" indicates the schema payload.\n    // The \"content\" is possibly binary and should not be touched & parsed.\n    if (\n      Buffer.isBuffer(value) &&\n      value.length > 0 &&\n      value.readUInt8(0) === 0\n    ) {\n      return value;\n    }\n\n    let result = value.toString();\n    const startChar = result.charAt(0);\n\n    // only try to parse objects and arrays\n    if (startChar === '{' || startChar === '[') {\n      try {\n        result = JSON.parse(value.toString());\n      } catch (e) {}\n    }\n    return result;\n  }\n}\n"]}