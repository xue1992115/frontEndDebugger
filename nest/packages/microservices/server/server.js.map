{"version":3,"file":"server.js","sourceRoot":"","sources":["server.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger, LoggerService } from '@nestjs/common/services/logger.service';\nimport { loadPackage } from '@nestjs/common/utils/load-package.util';\nimport {\n  connectable,\n  EMPTY,\n  from as fromPromise,\n  isObservable,\n  Observable,\n  ObservedValueOf,\n  of,\n  Subject,\n  Subscription,\n} from 'rxjs';\nimport { catchError, finalize, mergeMap } from 'rxjs/operators';\nimport { NO_EVENT_HANDLER } from '../constants';\nimport { BaseRpcContext } from '../ctx-host/base-rpc.context';\nimport { IncomingRequestDeserializer } from '../deserializers/incoming-request.deserializer';\nimport {\n  ClientOptions,\n  KafkaOptions,\n  MessageHandler,\n  MicroserviceOptions,\n  MqttOptions,\n  MsPattern,\n  NatsOptions,\n  ReadPacket,\n  RedisOptions,\n  RmqOptions,\n  TcpOptions,\n  WritePacket,\n} from '../interfaces';\nimport { ConsumerDeserializer } from '../interfaces/deserializer.interface';\nimport { ConsumerSerializer } from '../interfaces/serializer.interface';\nimport { IdentitySerializer } from '../serializers/identity.serializer';\nimport { transformPatternToRoute } from '../utils';\n\nexport abstract class Server {\n  protected readonly messageHandlers = new Map<string, MessageHandler>();\n  protected readonly logger: LoggerService = new Logger(Server.name);\n  protected serializer: ConsumerSerializer;\n  protected deserializer: ConsumerDeserializer;\n\n  public addHandler(\n    pattern: any,\n    callback: MessageHandler,\n    isEventHandler = false,\n    extras: Record<string, any> = {},\n  ) {\n    const normalizedPattern = this.normalizePattern(pattern);\n    callback.isEventHandler = isEventHandler;\n    callback.extras = extras;\n\n    if (this.messageHandlers.has(normalizedPattern) && isEventHandler) {\n      const headRef = this.messageHandlers.get(normalizedPattern);\n      const getTail = (handler: MessageHandler) =>\n        handler?.next ? getTail(handler.next) : handler;\n\n      const tailRef = getTail(headRef);\n      tailRef.next = callback;\n    } else {\n      this.messageHandlers.set(normalizedPattern, callback);\n    }\n  }\n\n  public getHandlers(): Map<string, MessageHandler> {\n    return this.messageHandlers;\n  }\n\n  public getHandlerByPattern(pattern: string): MessageHandler | null {\n    const route = this.getRouteFromPattern(pattern);\n    return this.messageHandlers.has(route)\n      ? this.messageHandlers.get(route)\n      : null;\n  }\n\n  public send(\n    stream$: Observable<any>,\n    respond: (data: WritePacket) => unknown | Promise<unknown>,\n  ): Subscription {\n    let dataBuffer: WritePacket[] = null;\n    const scheduleOnNextTick = (data: WritePacket) => {\n      if (!dataBuffer) {\n        dataBuffer = [data];\n        process.nextTick(async () => {\n          for (const item of dataBuffer) {\n            await respond(item);\n          }\n          dataBuffer = null;\n        });\n      } else if (!data.isDisposed) {\n        dataBuffer = dataBuffer.concat(data);\n      } else {\n        dataBuffer[dataBuffer.length - 1].isDisposed = data.isDisposed;\n      }\n    };\n    return stream$\n      .pipe(\n        catchError((err: any) => {\n          scheduleOnNextTick({ err });\n          return EMPTY;\n        }),\n        finalize(() => scheduleOnNextTick({ isDisposed: true })),\n      )\n      .subscribe((response: any) => scheduleOnNextTick({ response }));\n  }\n\n  public async handleEvent(\n    pattern: string,\n    packet: ReadPacket,\n    context: BaseRpcContext,\n  ): Promise<any> {\n    const handler = this.getHandlerByPattern(pattern);\n    if (!handler) {\n      return this.logger.error(NO_EVENT_HANDLER`${pattern}`);\n    }\n    const resultOrStream = await handler(packet.data, context);\n    if (isObservable(resultOrStream)) {\n      const connectableSource = connectable(resultOrStream, {\n        connector: () => new Subject(),\n        resetOnDisconnect: false,\n      });\n      connectableSource.connect();\n    }\n  }\n\n  public transformToObservable<T>(\n    resultOrDeferred: Observable<T> | Promise<T>,\n  ): Observable<T>;\n  public transformToObservable<T>(\n    resultOrDeferred: T,\n  ): never extends Observable<ObservedValueOf<T>>\n    ? Observable<T>\n    : Observable<ObservedValueOf<T>>;\n  public transformToObservable(resultOrDeferred: any) {\n    if (resultOrDeferred instanceof Promise) {\n      return fromPromise(resultOrDeferred).pipe(\n        mergeMap(val => (isObservable(val) ? val : of(val))),\n      );\n    }\n\n    if (isObservable(resultOrDeferred)) {\n      return resultOrDeferred;\n    }\n\n    return of(resultOrDeferred);\n  }\n\n  public getOptionsProp<\n    T extends MicroserviceOptions['options'],\n    K extends keyof T,\n  >(obj: T, prop: K, defaultValue: T[K] = undefined) {\n    return obj && prop in obj ? obj[prop] : defaultValue;\n  }\n\n  protected handleError(error: string) {\n    this.logger.error(error);\n  }\n\n  protected loadPackage<T = any>(\n    name: string,\n    ctx: string,\n    loader?: Function,\n  ): T {\n    return loadPackage(name, ctx, loader);\n  }\n\n  protected initializeSerializer(options: ClientOptions['options']) {\n    this.serializer =\n      (options &&\n        (\n          options as\n            | RedisOptions['options']\n            | NatsOptions['options']\n            | MqttOptions['options']\n            | TcpOptions['options']\n            | RmqOptions['options']\n            | KafkaOptions['options']\n        ).serializer) ||\n      new IdentitySerializer();\n  }\n\n  protected initializeDeserializer(options: ClientOptions['options']) {\n    this.deserializer =\n      (options &&\n        (\n          options as\n            | RedisOptions['options']\n            | NatsOptions['options']\n            | MqttOptions['options']\n            | TcpOptions['options']\n            | RmqOptions['options']\n            | KafkaOptions['options']\n        ).deserializer) ||\n      new IncomingRequestDeserializer();\n  }\n\n  /**\n   * Transforms the server Pattern to valid type and returns a route for him.\n   *\n   * @param  {string} pattern - server pattern\n   * @returns string\n   */\n  protected getRouteFromPattern(pattern: string): string {\n    let validPattern: MsPattern;\n\n    try {\n      validPattern = JSON.parse(pattern);\n    } catch (error) {\n      // Uses a fundamental object (`pattern` variable without any conversion)\n      validPattern = pattern;\n    }\n    return this.normalizePattern(validPattern);\n  }\n\n  protected normalizePattern(pattern: MsPattern): string {\n    return transformPatternToRoute(pattern);\n  }\n}\n"]}