{"version":3,"file":"client-tcp.js","sourceRoot":"","sources":["client-tcp.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger, Type } from '@nestjs/common';\nimport * as net from 'net';\nimport { EmptyError, lastValueFrom } from 'rxjs';\nimport { share, tap } from 'rxjs/operators';\nimport { ConnectionOptions } from 'tls';\nimport {\n  CLOSE_EVENT,\n  ECONNREFUSED,\n  ERROR_EVENT,\n  MESSAGE_EVENT,\n  TCP_DEFAULT_HOST,\n  TCP_DEFAULT_PORT,\n} from '../constants';\nimport { JsonSocket, TcpSocket } from '../helpers';\nimport { connect as tlsConnect, TLSSocket } from 'tls';\nimport { PacketId, ReadPacket, WritePacket } from '../interfaces';\nimport { TcpClientOptions } from '../interfaces/client-metadata.interface';\nimport { ClientProxy } from './client-proxy';\n\n/**\n * @publicApi\n */\nexport class ClientTCP extends ClientProxy {\n  protected connection: Promise<any>;\n  private readonly logger = new Logger(ClientTCP.name);\n  private readonly port: number;\n  private readonly host: string;\n  private readonly socketClass: Type<TcpSocket>;\n  private isConnected = false;\n  private socket: TcpSocket;\n  public tlsOptions?: ConnectionOptions;\n\n  constructor(options: TcpClientOptions['options']) {\n    super();\n    this.port = this.getOptionsProp(options, 'port') || TCP_DEFAULT_PORT;\n    this.host = this.getOptionsProp(options, 'host') || TCP_DEFAULT_HOST;\n    this.socketClass =\n      this.getOptionsProp(options, 'socketClass') || JsonSocket;\n    this.tlsOptions = this.getOptionsProp(options, 'tlsOptions');\n\n    this.initializeSerializer(options);\n    this.initializeDeserializer(options);\n  }\n\n  public connect(): Promise<any> {\n    if (this.connection) {\n      return this.connection;\n    }\n    this.socket = this.createSocket();\n    this.bindEvents(this.socket);\n\n    const source$ = this.connect$(this.socket.netSocket).pipe(\n      tap(() => {\n        this.isConnected = true;\n        this.socket.on(MESSAGE_EVENT, (buffer: WritePacket & PacketId) =>\n          this.handleResponse(buffer),\n        );\n      }),\n      share(),\n    );\n\n    // For TLS connections, the connection is initiated when the socket is created\n    if (!this.tlsOptions) {\n      this.socket.connect(this.port, this.host);\n    }\n    this.connection = lastValueFrom(source$).catch(err => {\n      if (err instanceof EmptyError) {\n        return;\n      }\n      throw err;\n    });\n\n    return this.connection;\n  }\n\n  public async handleResponse(buffer: unknown): Promise<void> {\n    const { err, response, isDisposed, id } =\n      await this.deserializer.deserialize(buffer);\n    const callback = this.routingMap.get(id);\n    if (!callback) {\n      return undefined;\n    }\n    if (isDisposed || err) {\n      return callback({\n        err,\n        response,\n        isDisposed: true,\n      });\n    }\n    callback({\n      err,\n      response,\n    });\n  }\n\n  public createSocket(): TcpSocket {\n    let socket: net.Socket | TLSSocket;\n    /**\n     * TLS enabled, \"upgrade\" the TCP Socket to TLS\n     */\n    if (this.tlsOptions) {\n      socket = tlsConnect({\n        ...this.tlsOptions,\n        port: this.port,\n        host: this.host,\n        socket,\n      });\n    } else {\n      socket = new net.Socket();\n    }\n    return new this.socketClass(socket);\n  }\n\n  public close() {\n    this.socket && this.socket.end();\n    this.handleClose();\n  }\n\n  public bindEvents(socket: TcpSocket) {\n    socket.on(\n      ERROR_EVENT,\n      (err: any) => err.code !== ECONNREFUSED && this.handleError(err),\n    );\n    socket.on(CLOSE_EVENT, () => this.handleClose());\n  }\n\n  public handleError(err: any) {\n    this.logger.error(err);\n  }\n\n  public handleClose() {\n    this.isConnected = false;\n    this.socket = null;\n    this.connection = undefined;\n\n    if (this.routingMap.size > 0) {\n      const err = new Error('Connection closed');\n      for (const callback of this.routingMap.values()) {\n        callback({ err });\n      }\n      this.routingMap.clear();\n    }\n  }\n\n  protected publish(\n    partialPacket: ReadPacket,\n    callback: (packet: WritePacket) => any,\n  ): () => void {\n    try {\n      const packet = this.assignPacketId(partialPacket);\n      const serializedPacket = this.serializer.serialize(packet);\n\n      this.routingMap.set(packet.id, callback);\n      this.socket.sendMessage(serializedPacket);\n\n      return () => this.routingMap.delete(packet.id);\n    } catch (err) {\n      callback({ err });\n    }\n  }\n\n  protected async dispatchEvent(packet: ReadPacket): Promise<any> {\n    const pattern = this.normalizePattern(packet.pattern);\n    const serializedPacket = this.serializer.serialize({\n      ...packet,\n      pattern,\n    });\n    return this.socket.sendMessage(serializedPacket);\n  }\n}\n"]}