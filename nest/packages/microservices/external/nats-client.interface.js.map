{"version":3,"file":"nats-client.interface.js","sourceRoot":"","sources":["nats-client.interface.ts"],"names":[],"mappings":"","sourcesContent":["/**\n * @see https://github.com/nats-io/nats.js\n *\n * @publicApi\n */\nexport interface NatsCodec<T> {\n  encode(d: T): Uint8Array;\n  decode(a: Uint8Array): T;\n}\n\ninterface RequestOptions {\n  timeout: number;\n  headers?: any;\n  noMux?: boolean;\n  reply?: string;\n}\ninterface PublishOptions {\n  reply?: string;\n  headers?: any;\n}\ninterface SubOpts<T> {\n  queue?: string;\n  max?: number;\n  timeout?: number;\n  callback?: (err: object | null, msg: T) => void;\n}\n\ndeclare type SubscriptionOptions = SubOpts<NatsMsg>;\n\nexport interface NatsMsg {\n  subject: string;\n  sid: number;\n  reply?: string;\n  data: Uint8Array;\n  headers?: any;\n  respond(data?: Uint8Array, opts?: PublishOptions): boolean;\n}\n\ninterface Sub<T> extends AsyncIterable<T> {\n  unsubscribe(max?: number): void;\n  drain(): Promise<void>;\n  isDraining(): boolean;\n  isClosed(): boolean;\n  callback(err: object | null, msg: NatsMsg): void;\n  getSubject(): string;\n  getReceived(): number;\n  getProcessed(): number;\n  getPending(): number;\n  getID(): number;\n  getMax(): number | undefined;\n}\n\ndeclare type Subscription = Sub<NatsMsg>;\n\ndeclare enum Events {\n  Disconnect = 'disconnect',\n  Reconnect = 'reconnect',\n  Update = 'update',\n  LDM = 'ldm',\n  Error = 'error',\n}\ninterface Status {\n  type: Events | DebugEvents;\n  data: string | number;\n}\n\ndeclare enum DebugEvents {\n  Reconnecting = 'reconnecting',\n  PingTimer = 'pingTimer',\n  StaleConnection = 'staleConnection',\n}\n\nexport declare class Client {\n  info?: Record<string, any>;\n  closed(): Promise<void | Error>;\n  close(): Promise<void>;\n  publish(subject: string, data?: Uint8Array, options?: PublishOptions): void;\n  subscribe(subject: string, opts?: SubscriptionOptions): Subscription;\n  request(\n    subject: string,\n    data?: Uint8Array,\n    opts?: RequestOptions,\n  ): Promise<NatsMsg>;\n  flush(): Promise<void>;\n  drain(): Promise<void>;\n  isClosed(): boolean;\n  isDraining(): boolean;\n  getServer(): string;\n  status(): AsyncIterable<Status>;\n  stats(): Record<string, any>;\n  jetstreamManager(opts?: Record<string, any>): Promise<any>;\n  jetstream(opts?: Record<string, any>): any;\n}\n"]}