{"version":3,"file":"redis.interface.js","sourceRoot":"","sources":["redis.interface.ts"],"names":[],"mappings":"","sourcesContent":["import { ConnectionOptions } from 'tls';\n\n/**\n * @see https://github.dev/luin/ioredis/blob/df04dd8d87a44d3b64b385c86581915248554508/lib/redis/RedisOptions.ts#L184\n *\n * @publicApi\n */\nexport interface IORedisOptions {\n  Connector?: any;\n  retryStrategy?: (times: number) => number | void | null;\n\n  /**\n   * If a command does not return a reply within a set number of milliseconds,\n   * a \"Command timed out\" error will be thrown.\n   */\n  commandTimeout?: number;\n  /**\n   * Enable/disable keep-alive functionality.\n   * @link https://nodejs.org/api/net.html#socketsetkeepaliveenable-initialdelay\n   * @default 0\n   */\n  keepAlive?: number;\n\n  /**\n   * Enable/disable the use of Nagle's algorithm.\n   * @link https://nodejs.org/api/net.html#socketsetnodelaynodelay\n   * @default true\n   */\n  noDelay?: boolean;\n\n  /**\n   * Set the name of the connection to make it easier to identity the connection\n   * in client list.\n   * @link https://redis.io/commands/client-setname\n   */\n  connectionName?: string;\n\n  /**\n   * If set, client will send AUTH command with the value of this option as the first argument when connected.\n   * This is supported since Redis 6.\n   */\n  username?: string;\n\n  /**\n   * If set, client will send AUTH command with the value of this option when connected.\n   */\n  password?: string;\n\n  /**\n   * Database index to use.\n   *\n   * @default 0\n   */\n  db?: number;\n\n  /**\n   * When the client reconnects, channels subscribed in the previous connection will be\n   * resubscribed automatically if `autoResubscribe` is `true`.\n   * @default true\n   */\n  autoResubscribe?: boolean;\n\n  /**\n   * Whether or not to resend unfulfilled commands on reconnect.\n   * Unfulfilled commands are most likely to be blocking commands such as `brpop` or `blpop`.\n   * @default true\n   */\n  autoResendUnfulfilledCommands?: boolean;\n  /**\n   * Whether or not to reconnect on certain Redis errors.\n   * This options by default is `null`, which means it should never reconnect on Redis errors.\n   * You can pass a function that accepts an Redis error, and returns:\n   * - `true` or `1` to trigger a reconnection.\n   * - `false` or `0` to not reconnect.\n   * - `2` to reconnect and resend the failed command (who triggered the error) after reconnection.\n   * @example\n   * ```js\n   * const redis = new Redis({\n   *   reconnectOnError(err) {\n   *     const targetError = \"READONLY\";\n   *     if (err.message.includes(targetError)) {\n   *       // Only reconnect when the error contains \"READONLY\"\n   *       return true; // or `return 1;`\n   *     }\n   *   },\n   * });\n   * ```\n   * @default null\n   */\n  reconnectOnError?: ((err: Error) => boolean | 1 | 2) | null;\n\n  /**\n   * @default false\n   */\n  readOnly?: boolean;\n  /**\n   * When enabled, numbers returned by Redis will be converted to JavaScript strings instead of numbers.\n   * This is necessary if you want to handle big numbers (above `Number.MAX_SAFE_INTEGER` === 2^53).\n   * @default false\n   */\n  stringNumbers?: boolean;\n\n  /**\n   * How long the client will wait before killing a socket due to inactivity during initial connection.\n   * @default 10000\n   */\n  connectTimeout?: number;\n\n  /**\n   * This option is used internally when you call `redis.monitor()` to tell Redis\n   * to enter the monitor mode when the connection is established.\n   *\n   * @default false\n   */\n  monitor?: boolean;\n\n  /**\n   * The commands that don't get a reply due to the connection to the server is lost are\n   * put into a queue and will be resent on reconnect (if allowed by the `retryStrategy` option).\n   * This option is used to configure how many reconnection attempts should be allowed before\n   * the queue is flushed with a `MaxRetriesPerRequestError` error.\n   * Set this options to `null` instead of a number to let commands wait forever\n   * until the connection is alive again.\n   *\n   * @default 20\n   */\n  maxRetriesPerRequest?: number | null;\n\n  /**\n   * @default 10000\n   */\n  maxLoadingRetryTime?: number;\n  /**\n   * @default false\n   */\n  enableAutoPipelining?: boolean;\n  /**\n   * @default []\n   */\n  autoPipeliningIgnoredCommands?: string[];\n  offlineQueue?: boolean;\n  commandQueue?: boolean;\n\n  /**\n   *\n   * By default, if the connection to Redis server has not been established, commands are added to a queue\n   * and are executed once the connection is \"ready\" (when `enableReadyCheck` is true, \"ready\" means\n   * the Redis server has loaded the database from disk, otherwise means the connection to the Redis\n   * server has been established). If this option is false, when execute the command when the connection\n   * isn't ready, an error will be returned.\n   *\n   * @default true\n   */\n  enableOfflineQueue?: boolean;\n\n  /**\n   * The client will sent an INFO command to check whether the server is still loading data from the disk (\n   * which happens when the server is just launched) when the connection is established, and only wait until\n   * the loading process is finished before emitting the `ready` event.\n   *\n   * @default true\n   */\n  enableReadyCheck?: boolean;\n\n  /**\n   * When a Redis instance is initialized, a connection to the server is immediately established. Set this to\n   * true will delay the connection to the server until the first command is sent or `redis.connect()` is called\n   * explicitly.\n   *\n   * @default false\n   */\n\n  lazyConnect?: boolean;\n\n  /**\n   * @default undefined\n   */\n  scripts?: Record<\n    string,\n    { lua: string; numberOfKeys?: number; readOnly?: boolean }\n  >;\n\n  keyPrefix?: string;\n  showFriendlyErrorStack?: boolean;\n\n  // StandaloneConnectionOptions\n  disconnectTimeout?: number;\n  tls?: ConnectionOptions;\n\n  // SentinelConnectionOptions\n  /**\n   * Master group name of the Sentinel\n   */\n  name?: string;\n  /**\n   * @default \"master\"\n   */\n  role?: 'master' | 'slave';\n  sentinelUsername?: string;\n  sentinelPassword?: string;\n  sentinels?: Array<Partial<any>>;\n  sentinelRetryStrategy?: (retryAttempts: number) => number | void | null;\n  sentinelReconnectStrategy?: (retryAttempts: number) => number | void | null;\n  preferredSlaves?: any;\n  sentinelCommandTimeout?: number;\n  enableTLSForSentinelMode?: boolean;\n  sentinelTLS?: ConnectionOptions;\n  natMap?: any;\n  updateSentinels?: boolean;\n  /**\n   * @default 10\n   */\n  sentinelMaxConnections?: number;\n  failoverDetector?: boolean;\n}\n"]}