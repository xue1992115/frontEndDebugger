{"version":3,"file":"mqtt-client.interface.js","sourceRoot":"","sources":["mqtt-client.interface.ts"],"names":[],"mappings":";;AAAA,mCAAsC","sourcesContent":["import { EventEmitter } from 'events';\n\n/**\n * @see https://github.com/mqttjs/MQTT.js/\n *\n * @publicApi\n *\n */\nexport declare class MqttClient extends EventEmitter {\n  public connected: boolean;\n  public disconnecting: boolean;\n  public disconnected: boolean;\n  public reconnecting: boolean;\n  public incomingStore: any;\n  public outgoingStore: any;\n  public options: any;\n  public queueQoSZero: boolean;\n\n  constructor(streamBuilder: (client: MqttClient) => any, options: any);\n\n  public on(event: 'message', cb: any): this;\n  public on(event: 'packetsend' | 'packetreceive', cb: any): this;\n  public on(event: 'error', cb: any): this;\n  public on(event: string, cb: Function): this;\n\n  public once(event: 'message', cb: any): this;\n  public once(event: 'packetsend' | 'packetreceive', cb: any): this;\n  public once(event: 'error', cb: any): this;\n  public once(event: string, cb: Function): this;\n\n  /**\n   * publish - publish <message> to <topic>\n   *\n   * @param {String} topic - topic to publish to\n   * @param {(String|Buffer)} message - message to publish\n   *\n   * @param {Object}    [opts] - publish options, includes:\n   *   @param {Number}  [opts.qos] - qos level to publish on\n   *   @param {Boolean} [opts.retain] - whether or not to retain the message\n   *\n   * @param {Function} [callback] - function(err){}\n   *    called when publish succeeds or fails\n   * @returns {Client} this - for chaining\n   * @api public\n   *\n   * @example client.publish('topic', 'message')\n   * @example\n   *     client.publish('topic', 'message', {qos: 1, retain: true})\n   * @example client.publish('topic', 'message', console.log)\n   */\n  public publish(\n    topic: string,\n    message: string | Buffer,\n    opts: any,\n    callback?: any,\n  ): this;\n  public publish(topic: string, message: string | Buffer, callback?: any): this;\n\n  /**\n   * subscribe - subscribe to <topic>\n   *\n   * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n   * @param {Object} [opts] - optional subscription options, includes:\n   * @param  {Number} [opts.qos] - subscribe qos level\n   * @param {Function} [callback] - function(err, granted){} where:\n   *    {Error} err - subscription error (none at the moment!)\n   *    {Array} granted - array of {topic: 't', qos: 0}\n   * @returns {MqttClient} this - for chaining\n   * @api public\n   * @example client.subscribe('topic')\n   * @example client.subscribe('topic', {qos: 1})\n   * @example client.subscribe({'topic': 0, 'topic2': 1}, console.log)\n   * @example client.subscribe('topic', console.log)\n   */\n  public subscribe(topic: string | string[], opts: any, callback?: any): this;\n  public subscribe(topic: string | string[] | any, callback?: any): this;\n\n  /**\n   * unsubscribe - unsubscribe from topic(s)\n   *\n   * @param {string|Array} topic - topics to unsubscribe from\n   * @param {Function} [callback] - callback fired on unsuback\n   * @returns {MqttClient} this - for chaining\n   * @api public\n   * @example client.unsubscribe('topic')\n   * @example client.unsubscribe('topic', console.log)\n   */\n  public unsubscribe(topic: string | string[], callback?: any): this;\n\n  /**\n   * end - close connection\n   *\n   * @returns {MqttClient} this - for chaining\n   * @param {Boolean} force - do not wait for all in-flight messages to be acked\n   * @param {Function} cb - called when the client has been closed\n   *\n   * @api public\n   */\n  public end(force?: boolean, cb?: any): this;\n\n  /**\n   * removeOutgoingMessage - remove a message in outgoing store\n   * the outgoing callback will be called withe Error('Message removed') if the message is removed\n   *\n   * @param {Number} mid - messageId to remove message\n   * @returns {MqttClient} this - for chaining\n   * @api public\n   *\n   * @example client.removeOutgoingMessage(client.getLastMessageId());\n   */\n  public removeOutgoingMessage(mid: number): this;\n\n  /**\n   * reconnect - connect again using the same options as connect()\n   *\n   * @param {Object} [opts] - optional reconnect options, includes:\n   *    {any} incomingStore - a store for the incoming packets\n   *    {any} outgoingStore - a store for the outgoing packets\n   *    if opts is not given, current stores are used\n   *\n   * @returns {MqttClient} this - for chaining\n   *\n   * @api public\n   */\n  public reconnect(opts?: any): this;\n\n  /**\n   * Handle messages with backpressure support, one at a time.\n   * Override at will.\n   *\n   * @param packet packet the packet\n   * @param callback callback call when finished\n   * @api public\n   */\n  public handleMessage(packet: any, callback: any): void;\n\n  /**\n   * getLastMessageId\n   */\n  public getLastMessageId(): number;\n}\n"]}