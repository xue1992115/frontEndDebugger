{"version":3,"file":"ws-adapter.js","sourceRoot":"/Users/hanxiaoxue/Documents/work/frontEndDebugger/nest/packages/websockets/","sources":["adapters/ws-adapter.ts"],"names":[],"mappings":";;;AAEA,oEAA+D;AAC/D,uCAA+C;AAE/C,4CAAkE;AAOlE,MAAsB,iBAAiB;IAQrC,YAAY,eAA+C;QACzD,IAAI,eAAe,IAAI,eAAe,YAAY,sBAAe,EAAE;YACjE,IAAI,CAAC,UAAU,GAAG,eAAe,CAAC,uBAAuB,EAAE,CAAC;SAC7D;aAAM;YACL,IAAI,CAAC,UAAU,GAAG,eAAe,CAAC;SACnC;IACH,CAAC;IAEM,iBAAiB,CAAC,MAAe,EAAE,QAAkB;QAC1D,MAAM,CAAC,EAAE,CAAC,4BAAgB,EAAE,QAAQ,CAAC,CAAC;IACxC,CAAC;IAEM,oBAAoB,CAAC,MAAe,EAAE,QAAkB;QAC7D,MAAM,CAAC,EAAE,CAAC,4BAAgB,EAAE,QAAQ,CAAC,CAAC;IACxC,CAAC;IAEM,KAAK,CAAC,KAAK,CAAC,MAAe;QAChC,MAAM,UAAU,GAAG,MAAM,IAAI,IAAA,yBAAU,EAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QACtD,UAAU,IAAI,CAAC,MAAM,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;IACtE,CAAC;IAED,gEAAgE;IACzD,KAAK,CAAC,OAAO,KAAI,CAAC;CAQ1B;AAtCD,8CAsCC","sourcesContent":["import { INestApplicationContext, WebSocketAdapter } from '@nestjs/common';\nimport { WsMessageHandler } from '@nestjs/common/interfaces';\nimport { isFunction } from '@nestjs/common/utils/shared.utils';\nimport { NestApplication } from '@nestjs/core';\nimport { Observable } from 'rxjs';\nimport { CONNECTION_EVENT, DISCONNECT_EVENT } from '../constants';\n\nexport interface BaseWsInstance {\n  on: (event: string, callback: Function) => void;\n  close: Function;\n}\n\nexport abstract class AbstractWsAdapter<\n  TServer extends BaseWsInstance = any,\n  TClient extends BaseWsInstance = any,\n  TOptions = any,\n> implements WebSocketAdapter<TServer, TClient, TOptions>\n{\n  protected readonly httpServer: any;\n\n  constructor(appOrHttpServer?: INestApplicationContext | any) {\n    if (appOrHttpServer && appOrHttpServer instanceof NestApplication) {\n      this.httpServer = appOrHttpServer.getUnderlyingHttpServer();\n    } else {\n      this.httpServer = appOrHttpServer;\n    }\n  }\n\n  public bindClientConnect(server: TServer, callback: Function) {\n    server.on(CONNECTION_EVENT, callback);\n  }\n\n  public bindClientDisconnect(client: TClient, callback: Function) {\n    client.on(DISCONNECT_EVENT, callback);\n  }\n\n  public async close(server: TServer) {\n    const isCallable = server && isFunction(server.close);\n    isCallable && (await new Promise(resolve => server.close(resolve)));\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  public async dispose() {}\n\n  public abstract create(port: number, options?: TOptions): TServer;\n  public abstract bindMessageHandlers(\n    client: TClient,\n    handlers: WsMessageHandler[],\n    transform: (data: any) => Observable<any>,\n  );\n}\n"]}