{"version":3,"file":"apply-decorators.js","sourceRoot":"/Users/hanxiaoxue/Documents/work/frontEndDebugger/nest/packages/common/","sources":["decorators/core/apply-decorators.ts"],"names":[],"mappings":";;;AAAA;;;;;;;;GAQG;AACH,SAAgB,eAAe,CAC7B,GAAG,UAAuE;IAE1E,OAAO,CACL,MAA0B,EAC1B,WAA6B,EAC7B,UAAuC,EACvC,EAAE;QACF,KAAK,MAAM,SAAS,IAAI,UAAU,EAAE;YAClC,IAAI,MAAM,YAAY,QAAQ,IAAI,CAAC,UAAU,EAAE;gBAC5C,SAA4B,CAAC,MAAM,CAAC,CAAC;gBACtC,SAAS;aACV;YACA,SAAiD,CAChD,MAAM,EACN,WAAW,EACX,UAAU,CACX,CAAC;SACH;IACH,CAAC,CAAC;AACJ,CAAC;AApBD,0CAoBC","sourcesContent":["/**\n * Function that returns a new decorator that applies all decorators provided by param\n *\n * Useful to build new decorators (or a decorator factory) encapsulating multiple decorators related with the same feature\n *\n * @param decorators one or more decorators (e.g., `ApplyGuard(...)`)\n *\n * @publicApi\n */\nexport function applyDecorators(\n  ...decorators: Array<ClassDecorator | MethodDecorator | PropertyDecorator>\n) {\n  return <TFunction extends Function, Y>(\n    target: TFunction | object,\n    propertyKey?: string | symbol,\n    descriptor?: TypedPropertyDescriptor<Y>,\n  ) => {\n    for (const decorator of decorators) {\n      if (target instanceof Function && !descriptor) {\n        (decorator as ClassDecorator)(target);\n        continue;\n      }\n      (decorator as MethodDecorator | PropertyDecorator)(\n        target,\n        propertyKey,\n        descriptor,\n      );\n    }\n  };\n}\n"]}