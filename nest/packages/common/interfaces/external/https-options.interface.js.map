{"version":3,"file":"https-options.interface.js","sourceRoot":"/Users/hanxiaoxue/Documents/work/frontEndDebugger/nest/packages/common/","sources":["interfaces/external/https-options.interface.ts"],"names":[],"mappings":"","sourcesContent":["/**\n * Interface describing Https Options that can be set.\n *\n * @see https://nodejs.org/api/tls.html\n *\n * @publicApi\n */\nexport interface HttpsOptions {\n  /**\n   * PFX or PKCS12 encoded private key and certificate chain. pfx is an alternative\n   * to providing key and cert individually. PFX is usually encrypted, if it is,\n   * passphrase will be used to decrypt it. Multiple PFX can be provided either\n   * as an array of unencrypted PFX buffers, or an array of objects in the form\n   * {buf: <string|buffer>[, passphrase: <string>]}. The object form can only\n   * occur in an array. object.passphrase is optional. Encrypted PFX will be decrypted\n   * with object.passphrase if provided, or options.passphrase if it is not.\n   */\n  pfx?: any;\n  /**\n   * Private keys in PEM format. PEM allows the option of private keys being encrypted.\n   * Encrypted keys will be decrypted with options.passphrase. Multiple keys using\n   * different algorithms can be provided either as an array of unencrypted key\n   * strings or buffers, or an array of objects in the form {pem: <string|buffer>[, passphrase: <string>]}.\n   * The object form can only occur in an array. object.passphrase is optional.\n   * Encrypted keys will be decrypted with object.passphrase if provided, or options.passphrase\n   * if it is not\n   */\n  key?: any;\n  /**\n   * Shared passphrase used for a single private key and/or a PFX.\n   */\n  passphrase?: string;\n  /**\n   * Cert chains in PEM format. One cert chain should be provided per private key.\n   * Each cert chain should consist of the PEM formatted certificate for a provided\n   * private key, followed by the PEM formatted intermediate certificates (if any),\n   * in order, and not including the root CA (the root CA must be pre-known to the\n   * peer, see ca). When providing multiple cert chains, they do not have to be\n   * in the same order as their private keys in key. If the intermediate certificates\n   * are not provided, the peer will not be able to validate the certificate, and\n   * the handshake will fail.\n   */\n  cert?: any;\n  /**\n   * Optionally override the trusted CA certificates. Default is to trust the well-known\n   * CAs curated by Mozilla. Mozilla's CAs are completely replaced when CAs are\n   * explicitly specified using this option. The value can be a string or Buffer,\n   * or an Array of strings and/or Buffers. Any string or Buffer can contain multiple\n   * PEM CAs concatenated together. The peer's certificate must be chainable to\n   * a CA trusted by the server for the connection to be authenticated. When using\n   * certificates that are not chainable to a well-known CA, the certificate's CA\n   * must be explicitly specified as a trusted or the connection will fail to authenticate.\n   * If the peer uses a certificate that doesn't match or chain to one of the default\n   * CAs, use the ca option to provide a CA certificate that the peer's certificate\n   * can match or chain to. For self-signed certificates, the certificate is its\n   * own CA, and must be provided. For PEM encoded certificates, supported types\n   * are \"TRUSTED CERTIFICATE\", \"X509 CERTIFICATE\", and \"CERTIFICATE\". See also tls.rootCertificates.\n   */\n  ca?: any;\n  /**\n   * PEM formatted CRLs (Certificate Revocation Lists).\n   */\n  crl?: any;\n  /**\n   * Cipher suite specification, replacing the default. For more information, see\n   * modifying the default cipher suite. Permitted ciphers can be obtained via tls.getCiphers().\n   * Cipher names must be uppercased in order for OpenSSL to accept them.\n   */\n  ciphers?: string;\n  /**\n   * Attempt to use the server's cipher suite preferences instead of the client's.\n   * When true, causes SSL_OP_CIPHER_SERVER_PREFERENCE to be set in secureOptions,\n   * see OpenSSL Options for more information.\n   */\n  honorCipherOrder?: boolean;\n  /**\n   * If true the server will request a certificate from clients that connect and\n   * attempt to verify that certificate. Default: false.\n   */\n  requestCert?: boolean;\n  /**\n   * If not false the server will reject any connection which is not authorized\n   * with the list of supplied CAs. This option only has an effect if requestCert is true. Default: true\n   */\n  rejectUnauthorized?: boolean;\n  /**\n   * An array or Buffer of possible NPN protocols. (Protocols should be ordered\n   * by their priority).\n   */\n  NPNProtocols?: any;\n  /**\n   * A function that will be called if the client supports SNI TLS extension. Two\n   * arguments will be passed when called: servername and cb. SNICallback should\n   * invoke cb(null, ctx), where ctx is a SecureContext instance. (tls.createSecureContext(...)\n   * can be used to get a proper SecureContext.) If SNICallback wasn't provided\n   * the default callback with high-level API will be used.\n   */\n  SNICallback?: (servername: string, cb: (err: Error, ctx: any) => any) => any;\n}\n"]}