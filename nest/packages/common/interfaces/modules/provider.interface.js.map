{"version":3,"file":"provider.interface.js","sourceRoot":"/Users/hanxiaoxue/Documents/work/frontEndDebugger/nest/packages/common/","sources":["interfaces/modules/provider.interface.ts"],"names":[],"mappings":"","sourcesContent":["import { Scope } from '../scope-options.interface';\nimport { Type } from '../type.interface';\nimport { InjectionToken } from './injection-token.interface';\nimport { OptionalFactoryDependency } from './optional-factory-dependency.interface';\n\n/**\n *\n * @publicApi\n */\nexport type Provider<T = any> =\n  | Type<any>\n  | ClassProvider<T>\n  | ValueProvider<T>\n  | FactoryProvider<T>\n  | ExistingProvider<T>;\n\n/**\n * Interface defining a *Class* type provider.\n *\n * For example:\n * ```typescript\n * const configServiceProvider = {\n * provide: ConfigService,\n * useClass:\n *   process.env.NODE_ENV === 'development'\n *     ? DevelopmentConfigService\n *     : ProductionConfigService,\n * };\n * ```\n *\n * @see [Class providers](https://docs.nestjs.com/fundamentals/custom-providers#class-providers-useclass)\n * @see [Injection scopes](https://docs.nestjs.com/fundamentals/injection-scopes)\n *\n * @publicApi\n */\nexport interface ClassProvider<T = any> {\n  /**\n   * Injection token\n   */\n  provide: InjectionToken;\n  /**\n   * Type (class name) of provider (instance to be injected).\n   */\n  useClass: Type<T>;\n  /**\n   * Optional enum defining lifetime of the provider that is injected.\n   */\n  scope?: Scope;\n  /**\n   * This option is only available on factory providers!\n   *\n   * @see [Use factory](https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory)\n   */\n  inject?: never;\n  /**\n   * Flags provider as durable. This flag can be used in combination with custom context id\n   * factory strategy to construct lazy DI subtrees.\n   *\n   * This flag can be used only in conjunction with scope = Scope.REQUEST.\n   */\n  durable?: boolean;\n}\n\n/**\n * Interface defining a *Value* type provider.\n *\n * For example:\n * ```typescript\n * const connectionProvider = {\n *   provide: 'CONNECTION',\n *   useValue: connection,\n * };\n * ```\n *\n * @see [Value providers](https://docs.nestjs.com/fundamentals/custom-providers#value-providers-usevalue)\n *\n * @publicApi\n */\nexport interface ValueProvider<T = any> {\n  /**\n   * Injection token\n   */\n  provide: InjectionToken;\n  /**\n   * Instance of a provider to be injected.\n   */\n  useValue: T;\n  /**\n   * This option is only available on factory providers!\n   *\n   * @see [Use factory](https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory)\n   */\n  inject?: never;\n}\n\n/**\n * Interface defining a *Factory* type provider.\n *\n * For example:\n * ```typescript\n * const connectionFactory = {\n *   provide: 'CONNECTION',\n *   useFactory: (optionsProvider: OptionsProvider) => {\n *     const options = optionsProvider.get();\n *     return new DatabaseConnection(options);\n *   },\n *   inject: [OptionsProvider],\n * };\n * ```\n *\n * @see [Factory providers](https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory)\n * @see [Injection scopes](https://docs.nestjs.com/fundamentals/injection-scopes)\n *\n * @publicApi\n */\nexport interface FactoryProvider<T = any> {\n  /**\n   * Injection token\n   */\n  provide: InjectionToken;\n  /**\n   * Factory function that returns an instance of the provider to be injected.\n   */\n  useFactory: (...args: any[]) => T | Promise<T>;\n  /**\n   * Optional list of providers to be injected into the context of the Factory function.\n   */\n  inject?: Array<InjectionToken | OptionalFactoryDependency>;\n  /**\n   * Optional enum defining lifetime of the provider that is returned by the Factory function.\n   */\n  scope?: Scope;\n  /**\n   * Flags provider as durable. This flag can be used in combination with custom context id\n   * factory strategy to construct lazy DI subtrees.\n   *\n   * This flag can be used only in conjunction with scope = Scope.REQUEST.\n   */\n  durable?: boolean;\n}\n\n/**\n * Interface defining an *Existing* (aliased) type provider.\n *\n * For example:\n * ```typescript\n * const loggerAliasProvider = {\n *   provide: 'AliasedLoggerService',\n *   useExisting: LoggerService\n * };\n * ```\n *\n * @see [Alias providers](https://docs.nestjs.com/fundamentals/custom-providers#alias-providers-useexisting)\n *\n * @publicApi\n */\nexport interface ExistingProvider<T = any> {\n  /**\n   * Injection token\n   */\n  provide: InjectionToken;\n  /**\n   * Provider to be aliased by the Injection token.\n   */\n  useExisting: any;\n}\n"]}