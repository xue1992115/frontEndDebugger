{"version":3,"file":"get-injection-providers.util.js","sourceRoot":"/Users/hanxiaoxue/Documents/work/frontEndDebugger/nest/packages/common/","sources":["module-utils/utils/get-injection-providers.util.ts"],"names":[],"mappings":";;;AAOA;;;;;GAKG;AACH,SAAS,2BAA2B,CAClC,CAA6C;IAE7C,OAAO,CAAC,CAAC,CAAC,CAAC,CAAS,aAAT,CAAC,uBAAD,CAAC,CAAU,KAAK,KAAI,CAAC,CAAC,CAAS,aAAT,CAAC,uBAAD,CAAC,CAAU,SAAS,CAAA,CAAC,CAAC;AACzD,CAAC;AAED,MAAM,iBAAiB,GAAG,CAAC,CAA6C,EAAE,EAAE,CAC1E,2BAA2B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;AAE/C;;;;;GAKG;AACH,SAAgB,qBAAqB,CACnC,SAAqB,EACrB,MAAiC;IAEjC,MAAM,MAAM,GAAe,EAAE,CAAC;IAC9B,IAAI,MAAM,GAAqB,MAAM,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAC;IAC7D,OAAO,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;QACxB,MAAM,KAAK,GAAG,CAAC,SAAS,aAAT,SAAS,cAAT,SAAS,GAAI,EAAE,CAAC,CAAC,MAAM,CACpC,CAAC,CAAC,EAAE,CACF,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,+CAA+C;YACtE,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAQ,CAAC,IAAI,MAAM,CAAC,QAAQ,CAAE,CAAS,aAAT,CAAC,uBAAD,CAAC,CAAU,OAAO,CAAC,CAAC,CACtE,CAAC;QACF,MAAM,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,CAAC;QACtB,wDAAwD;QACxD,MAAM,GAAG,KAAK;aACX,MAAM,CAAC,CAAC,CAAC,EAAE,CAAE,CAAS,aAAT,CAAC,uBAAD,CAAC,CAAU,MAAM,CAAC;aAC/B,GAAG,CAAC,CAAC,CAAC,EAAE,CAAE,CAAqB,CAAC,MAAM,CAAC;aACvC,IAAI,EAAE;aACN,GAAG,CAAC,iBAAiB,CAAC,CAAC;KAC3B;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AArBD,sDAqBC","sourcesContent":["import {\n  InjectionToken,\n  Provider,\n  FactoryProvider,\n  OptionalFactoryDependency,\n} from '../../interfaces';\n\n/**\n * check if x is OptionalFactoryDependency, based on prototype presence\n * (to avoid classes with a static 'token' field)\n * @param x\n * @returns x is OptionalFactoryDependency\n */\nfunction isOptionalFactoryDependency(\n  x: InjectionToken | OptionalFactoryDependency,\n): x is OptionalFactoryDependency {\n  return !!((x as any)?.token && !(x as any)?.prototype);\n}\n\nconst mapInjectToTokens = (t: InjectionToken | OptionalFactoryDependency) =>\n  isOptionalFactoryDependency(t) ? t.token : t;\n\n/**\n *\n * @param providers List of a module's providers\n * @param tokens Injection tokens needed for a useFactory function (usually the module's options' token)\n * @returns All the providers needed for the tokens' injection (searched recursively)\n */\nexport function getInjectionProviders(\n  providers: Provider[],\n  tokens: FactoryProvider['inject'],\n): Provider[] {\n  const result: Provider[] = [];\n  let search: InjectionToken[] = tokens.map(mapInjectToTokens);\n  while (search.length > 0) {\n    const match = (providers ?? []).filter(\n      p =>\n        !result.includes(p) && // this prevents circular loops and duplication\n        (search.includes(p as any) || search.includes((p as any)?.provide)),\n    );\n    result.push(...match);\n    // get injection tokens of the matched providers, if any\n    search = match\n      .filter(p => (p as any)?.inject)\n      .map(p => (p as FactoryProvider).inject)\n      .flat()\n      .map(mapInjectToTokens);\n  }\n  return result;\n}\n"]}