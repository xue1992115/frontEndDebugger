{"version":3,"file":"configurable-module.builder.js","sourceRoot":"/Users/hanxiaoxue/Documents/work/frontEndDebugger/nest/packages/common/","sources":["module-utils/configurable-module.builder.ts"],"names":[],"mappings":"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","sourcesContent":["import { DynamicModule, Provider } from '../interfaces';\nimport { Logger } from '../services/logger.service';\nimport { randomStringGenerator } from '../utils/random-string-generator.util';\nimport {\n  ASYNC_METHOD_SUFFIX,\n  CONFIGURABLE_MODULE_ID,\n  DEFAULT_FACTORY_CLASS_METHOD_KEY,\n  DEFAULT_METHOD_KEY,\n} from './constants';\nimport {\n  ConfigurableModuleAsyncOptions,\n  ConfigurableModuleCls,\n  ConfigurableModuleHost,\n  ConfigurableModuleOptionsFactory,\n} from './interfaces';\nimport { generateOptionsInjectionToken, getInjectionProviders } from './utils';\n\n/**\n * @publicApi\n */\nexport interface ConfigurableModuleBuilderOptions {\n  /**\n   * Specified what injection token should be used for the module options provider.\n   * By default, an auto-generated UUID will be used.\n   */\n  optionsInjectionToken?: string | symbol;\n  /**\n   * By default, an UUID will be used as a module options provider token.\n   * Explicitly specifying the \"moduleName\" will instruct the \"ConfigurableModuleBuilder\"\n   * to use a more descriptive provider token.\n   *\n   * For example, if `moduleName: \"Cache\"` then auto-generated provider token will be \"CACHE_MODULE_OPTIONS\".\n   */\n  moduleName?: string;\n  /**\n   * Indicates whether module should always be \"transient\", meaning,\n   * every time you call the static method to construct a dynamic module,\n   * regardless of what arguments you pass in, a new \"unique\" module will be created.\n   *\n   * @default false\n   */\n  alwaysTransient?: boolean;\n}\n\n/**\n * Factory that lets you create configurable modules and\n * provides a way to reduce the majority of dynamic module boilerplate.\n *\n * @publicApi\n */\nexport class ConfigurableModuleBuilder<\n  ModuleOptions,\n  StaticMethodKey extends string = typeof DEFAULT_METHOD_KEY,\n  FactoryClassMethodKey extends string = typeof DEFAULT_FACTORY_CLASS_METHOD_KEY,\n  ExtraModuleDefinitionOptions = {},\n> {\n  protected staticMethodKey: StaticMethodKey;\n  protected factoryClassMethodKey: FactoryClassMethodKey;\n  protected extras: ExtraModuleDefinitionOptions;\n  protected transformModuleDefinition: (\n    definition: DynamicModule,\n    extraOptions: ExtraModuleDefinitionOptions,\n  ) => DynamicModule;\n\n  protected readonly logger = new Logger(ConfigurableModuleBuilder.name);\n\n  constructor(\n    protected readonly options: ConfigurableModuleBuilderOptions = {},\n    parentBuilder?: ConfigurableModuleBuilder<ModuleOptions>,\n  ) {\n    if (parentBuilder) {\n      this.staticMethodKey = parentBuilder.staticMethodKey as StaticMethodKey;\n      this.factoryClassMethodKey =\n        parentBuilder.factoryClassMethodKey as FactoryClassMethodKey;\n      this.transformModuleDefinition = parentBuilder.transformModuleDefinition;\n      this.extras = parentBuilder.extras as ExtraModuleDefinitionOptions;\n    }\n  }\n\n  /**\n   * Registers the \"extras\" object (a set of extra options that can be used to modify the dynamic module definition).\n   * Values you specify within the \"extras\" object will be used as default values (that can be overridden by module consumers).\n   *\n   * This method also applies the so-called \"module definition transform function\" that takes the auto-generated\n   * dynamic module object (\"DynamicModule\") and the actual consumer \"extras\" object as input parameters.\n   * The \"extras\" object consists of values explicitly specified by module consumers and default values.\n   *\n   * @example\n   * ```typescript\n   * .setExtras<{ isGlobal?: boolean }>({ isGlobal: false }, (definition, extras) =>\n   *    ({ ...definition, global: extras.isGlobal })\n   * )\n   * ```\n   */\n  setExtras<ExtraModuleDefinitionOptions>(\n    extras: ExtraModuleDefinitionOptions,\n    transformDefinition: (\n      definition: DynamicModule,\n      extras: ExtraModuleDefinitionOptions,\n    ) => DynamicModule = def => def,\n  ) {\n    const builder = new ConfigurableModuleBuilder<\n      ModuleOptions,\n      StaticMethodKey,\n      FactoryClassMethodKey,\n      ExtraModuleDefinitionOptions\n    >(this.options, this as any);\n    builder.extras = extras;\n    builder.transformModuleDefinition = transformDefinition;\n    return builder;\n  }\n\n  /**\n   * Dynamic modules must expose public static methods that let you pass in\n   * configuration parameters (control the module's behavior from the outside).\n   * Some frequently used names that you may have seen in other modules are:\n   * \"forRoot\", \"forFeature\", \"register\", \"configure\".\n   *\n   * This method \"setClassMethodName\" lets you specify the name of the\n   * method that will be auto-generated.\n   *\n   * @param key name of the method\n   */\n  setClassMethodName<StaticMethodKey extends string>(key: StaticMethodKey) {\n    const builder = new ConfigurableModuleBuilder<\n      ModuleOptions,\n      StaticMethodKey,\n      FactoryClassMethodKey,\n      ExtraModuleDefinitionOptions\n    >(this.options, this as any);\n    builder.staticMethodKey = key;\n    return builder;\n  }\n\n  /**\n   * Asynchronously configured modules (that rely on other modules, i.e. \"ConfigModule\")\n   * let you pass the configuration factory class that will be registered and instantiated as a provider.\n   * This provider then will be used to retrieve the module's configuration. To provide the configuration,\n   * the corresponding factory method must be implemented.\n   *\n   * This method (\"setFactoryMethodName\") lets you control what method name will have to be\n   * implemented by the config factory (default is \"create\").\n   *\n   * @param key name of the method\n   */\n  setFactoryMethodName<FactoryClassMethodKey extends string>(\n    key: FactoryClassMethodKey,\n  ) {\n    const builder = new ConfigurableModuleBuilder<\n      ModuleOptions,\n      StaticMethodKey,\n      FactoryClassMethodKey,\n      ExtraModuleDefinitionOptions\n    >(this.options, this as any);\n    builder.factoryClassMethodKey = key;\n    return builder;\n  }\n\n  /**\n   * Returns an object consisting of multiple properties that lets you\n   * easily construct dynamic configurable modules. See \"ConfigurableModuleHost\" interface for more details.\n   */\n  build(): ConfigurableModuleHost<\n    ModuleOptions,\n    StaticMethodKey,\n    FactoryClassMethodKey,\n    ExtraModuleDefinitionOptions\n  > {\n    this.staticMethodKey ??= DEFAULT_METHOD_KEY as StaticMethodKey;\n    this.factoryClassMethodKey ??=\n      DEFAULT_FACTORY_CLASS_METHOD_KEY as FactoryClassMethodKey;\n    this.options.optionsInjectionToken ??= this.options.moduleName\n      ? this.constructInjectionTokenString()\n      : generateOptionsInjectionToken();\n    this.transformModuleDefinition ??= definition => definition;\n\n    return {\n      ConfigurableModuleClass:\n        this.createConfigurableModuleCls<ModuleOptions>(),\n      MODULE_OPTIONS_TOKEN: this.options.optionsInjectionToken,\n      ASYNC_OPTIONS_TYPE: this.createTypeProxy('ASYNC_OPTIONS_TYPE'),\n      OPTIONS_TYPE: this.createTypeProxy('OPTIONS_TYPE'),\n    };\n  }\n\n  private constructInjectionTokenString(): string {\n    const moduleNameInSnakeCase = this.options.moduleName\n      .trim()\n      .split(/(?=[A-Z])/)\n      .join('_')\n      .toUpperCase();\n    return `${moduleNameInSnakeCase}_MODULE_OPTIONS`;\n  }\n\n  private createConfigurableModuleCls<ModuleOptions>(): ConfigurableModuleCls<\n    ModuleOptions,\n    StaticMethodKey,\n    FactoryClassMethodKey\n  > {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    const asyncMethodKey = this.staticMethodKey + ASYNC_METHOD_SUFFIX;\n\n    class InternalModuleClass {\n      static [self.staticMethodKey](\n        options: ModuleOptions & ExtraModuleDefinitionOptions,\n      ): DynamicModule {\n        const providers: Array<Provider> = [\n          {\n            provide: self.options.optionsInjectionToken,\n            useValue: this.omitExtras(options, self.extras),\n          },\n        ];\n        if (self.options.alwaysTransient) {\n          providers.push({\n            provide: CONFIGURABLE_MODULE_ID,\n            useValue: randomStringGenerator(),\n          });\n        }\n        return self.transformModuleDefinition(\n          {\n            module: this,\n            providers,\n          },\n          {\n            ...self.extras,\n            ...options,\n          },\n        );\n      }\n\n      static [asyncMethodKey](\n        options: ConfigurableModuleAsyncOptions<ModuleOptions> &\n          ExtraModuleDefinitionOptions,\n      ): DynamicModule {\n        const providers = this.createAsyncProviders(options);\n        if (self.options.alwaysTransient) {\n          providers.push({\n            provide: CONFIGURABLE_MODULE_ID,\n            useValue: randomStringGenerator(),\n          });\n        }\n        return self.transformModuleDefinition(\n          {\n            module: this,\n            imports: options.imports || [],\n            providers,\n          },\n          {\n            ...self.extras,\n            ...options,\n          },\n        );\n      }\n\n      private static omitExtras(\n        input: ModuleOptions & ExtraModuleDefinitionOptions,\n        extras: ExtraModuleDefinitionOptions | undefined,\n      ): ModuleOptions {\n        if (!extras) {\n          return input;\n        }\n        const moduleOptions = {};\n        const extrasKeys = Object.keys(extras);\n\n        Object.keys(input)\n          .filter(key => !extrasKeys.includes(key))\n          .forEach(key => {\n            moduleOptions[key] = input[key];\n          });\n        return moduleOptions as ModuleOptions;\n      }\n\n      private static createAsyncProviders(\n        options: ConfigurableModuleAsyncOptions<ModuleOptions>,\n      ): Provider[] {\n        if (options.useExisting || options.useFactory) {\n          if (options.inject && options.provideInjectionTokensFrom) {\n            return [\n              this.createAsyncOptionsProvider(options),\n              ...getInjectionProviders(\n                options.provideInjectionTokensFrom,\n                options.inject,\n              ),\n            ];\n          }\n          return [this.createAsyncOptionsProvider(options)];\n        }\n        return [\n          this.createAsyncOptionsProvider(options),\n          {\n            provide: options.useClass,\n            useClass: options.useClass,\n          },\n        ];\n      }\n\n      private static createAsyncOptionsProvider(\n        options: ConfigurableModuleAsyncOptions<ModuleOptions>,\n      ): Provider {\n        if (options.useFactory) {\n          return {\n            provide: self.options.optionsInjectionToken,\n            useFactory: options.useFactory,\n            inject: options.inject || [],\n          };\n        }\n        return {\n          provide: self.options.optionsInjectionToken,\n          useFactory: async (\n            optionsFactory: ConfigurableModuleOptionsFactory<\n              ModuleOptions,\n              FactoryClassMethodKey\n            >,\n          ) =>\n            await optionsFactory[\n              self.factoryClassMethodKey as keyof typeof optionsFactory\n            ](),\n          inject: [options.useExisting || options.useClass],\n        };\n      }\n    }\n    return InternalModuleClass as unknown as ConfigurableModuleCls<\n      ModuleOptions,\n      StaticMethodKey,\n      FactoryClassMethodKey\n    >;\n  }\n\n  private createTypeProxy(\n    typeName: 'OPTIONS_TYPE' | 'ASYNC_OPTIONS_TYPE' | 'OptionsFactoryInterface',\n  ) {\n    const proxy = new Proxy(\n      {},\n      {\n        get: () => {\n          throw new Error(\n            `\"${typeName}\" is not supposed to be used as a value.`,\n          );\n        },\n      },\n    );\n    return proxy as any;\n  }\n}\n"]}