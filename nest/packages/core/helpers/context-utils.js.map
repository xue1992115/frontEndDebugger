{"version":3,"file":"context-utils.js","sourceRoot":"/Users/hanxiaoxue/Documents/work/frontEndDebugger/nest/packages/core/","sources":["helpers/context-utils.ts"],"names":[],"mappings":";;;AACA,wDAGkC;AAOlC,oEAA+D;AAC/D,qEAAgE;AAUhE,MAAa,YAAY;IAChB,YAAY,CAAC,GAAW;QAC7B,MAAM,OAAO,GAAG,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC/B,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC;IACpB,CAAC;IAEM,yBAAyB,CAC9B,QAAoB,EACpB,UAAkB;QAElB,OAAO,OAAO,CAAC,WAAW,CAAC,+BAAmB,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAC;IACxE,CAAC;IAEM,uBAAuB,CAC5B,QAAoB,EACpB,UAAkB,EAClB,WAAmB;QAEnB,OAAO,OAAO,CAAC,WAAW,CAAC,WAAW,EAAE,QAAQ,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;IAC5E,CAAC;IAEM,kBAAkB,CAAC,QAAoB,EAAE,UAAkB;QAChE,OAAO,OAAO,CAAC,WAAW,CACxB,yCAA6B,EAC7B,QAAQ,CAAC,WAAW,EACpB,UAAU,CACX,CAAC;IACJ,CAAC;IAEM,kBAAkB,CAAI,IAAc,EAAE,QAAW;QACtD,OAAO,IAAI,CAAC,MAAM;YAChB,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC;YACvD,CAAC,CAAC,CAAC,CAAC;IACR,CAAC;IAEM,eAAe,CAAC,MAAc;QACnC,MAAM,CAAC,GAAG,IAAI,KAAK,CAAC,MAAM,CAAC,CAAC;QAC5B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,EAAE,CAAC;YAAE,CAAC,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC;QAClD,OAAO,CAAC,CAAC;IACX,CAAC;IAEM,oBAAoB,CACzB,gBAAmC,EACnC,UAAiB;QAEjB,IAAI,CAAC,UAAU,EAAE;YACf,OAAO,gBAAgB,CAAC;SACzB;QACD,OAAO,gBAAgB,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,iCAChC,KAAK,KACR,QAAQ,EAAE,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,IACjC,CAAC,CAAC;IACN,CAAC;IAEM,gBAAgB,CACrB,OAAqC,EACrC,IAAa,EACb,cAAyD;QAEzD,OAAO,IAAA,yBAAU,EAAC,OAAO,CAAC;YACxB,CAAC,CAAC,CAAC,GAAG,IAAe,EAAE,EAAE,CAAC,OAAO,CAAC,IAAI,EAAE,cAAc,CAAC,IAAI,CAAC,CAAC;YAC7D,CAAC,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC;IACjB,CAAC;IAEM,iBAAiB,CACtB,WAAqB,EACrB,QAAiB,EACjB,QAAmB;QAEnB,MAAM,cAAc,GAAG,CAAC,IAAe,EAAE,EAAE;YACzC,MAAM,GAAG,GAAG,IAAI,6CAAoB,CAClC,IAAI,EACJ,QAAQ,IAAK,QAAQ,CAAC,WAA6B,EACnD,QAAQ,CACT,CAAC;YACF,GAAG,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;YACzB,OAAO,GAAG,CAAC;QACb,CAAC,CAAC;QACF,OAAO,cAAc,CAAC;IACxB,CAAC;CACF;AAhFD,oCAgFC","sourcesContent":["import { ParamData } from '@nestjs/common';\nimport {\n  PARAMTYPES_METADATA,\n  RESPONSE_PASSTHROUGH_METADATA,\n} from '@nestjs/common/constants';\nimport {\n  ContextType,\n  Controller,\n  PipeTransform,\n  Type,\n} from '@nestjs/common/interfaces';\nimport { isFunction } from '@nestjs/common/utils/shared.utils';\nimport { ExecutionContextHost } from './execution-context-host';\n\nexport interface ParamProperties<T = any, IExtractor extends Function = any> {\n  index: number;\n  type: T | string;\n  data: ParamData;\n  pipes: PipeTransform[];\n  extractValue: IExtractor;\n}\n\nexport class ContextUtils {\n  public mapParamType(key: string): string {\n    const keyPair = key.split(':');\n    return keyPair[0];\n  }\n\n  public reflectCallbackParamtypes(\n    instance: Controller,\n    methodName: string,\n  ): any[] {\n    return Reflect.getMetadata(PARAMTYPES_METADATA, instance, methodName);\n  }\n\n  public reflectCallbackMetadata<T = any>(\n    instance: Controller,\n    methodName: string,\n    metadataKey: string,\n  ): T {\n    return Reflect.getMetadata(metadataKey, instance.constructor, methodName);\n  }\n\n  public reflectPassthrough(instance: Controller, methodName: string): boolean {\n    return Reflect.getMetadata(\n      RESPONSE_PASSTHROUGH_METADATA,\n      instance.constructor,\n      methodName,\n    );\n  }\n\n  public getArgumentsLength<T>(keys: string[], metadata: T): number {\n    return keys.length\n      ? Math.max(...keys.map(key => metadata[key].index)) + 1\n      : 0;\n  }\n\n  public createNullArray(length: number): any[] {\n    const a = new Array(length);\n    for (let i = 0; i < length; ++i) a[i] = undefined;\n    return a;\n  }\n\n  public mergeParamsMetatypes(\n    paramsProperties: ParamProperties[],\n    paramtypes: any[],\n  ): (ParamProperties & { metatype?: any })[] {\n    if (!paramtypes) {\n      return paramsProperties;\n    }\n    return paramsProperties.map(param => ({\n      ...param,\n      metatype: paramtypes[param.index],\n    }));\n  }\n\n  public getCustomFactory(\n    factory: (...args: unknown[]) => void,\n    data: unknown,\n    contextFactory: (args: unknown[]) => ExecutionContextHost,\n  ): (...args: unknown[]) => unknown {\n    return isFunction(factory)\n      ? (...args: unknown[]) => factory(data, contextFactory(args))\n      : () => null;\n  }\n\n  public getContextFactory<TContext extends string = ContextType>(\n    contextType: TContext,\n    instance?: object,\n    callback?: Function,\n  ): (args: unknown[]) => ExecutionContextHost {\n    const contextFactory = (args: unknown[]) => {\n      const ctx = new ExecutionContextHost(\n        args,\n        instance && (instance.constructor as Type<unknown>),\n        callback,\n      );\n      ctx.setType(contextType);\n      return ctx;\n    };\n    return contextFactory;\n  }\n}\n"]}