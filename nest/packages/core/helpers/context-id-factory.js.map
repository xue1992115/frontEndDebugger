{"version":3,"file":"context-id-factory.js","sourceRoot":"/Users/hanxiaoxue/Documents/work/frontEndDebugger/nest/packages/core/","sources":["helpers/context-id-factory.ts"],"names":[],"mappings":";;;AAAA,oEAA6D;AAE7D,2EAAyE;AAEzE,SAAgB,eAAe;IAC7B;;;;;;;OAOG;IACH,OAAO,EAAE,EAAE,EAAE,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC;AAC/B,CAAC;AAVD,0CAUC;AA4BD,MAAa,gBAAgB;IAG3B;;OAEG;IACI,MAAM,CAAC,MAAM;QAClB,OAAO,eAAe,EAAE,CAAC;IAC3B,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,YAAY,CACxB,OAAU,EACV,iBAA2B,CAAC,KAAK,CAAC;;QAElC,IAAI,CAAC,OAAO,EAAE;YACZ,OAAO,gBAAgB,CAAC,MAAM,EAAE,CAAC;SAClC;QACD,IAAI,OAAO,CAAC,sCAAyB,CAAC,EAAE;YACtC,OAAO,OAAO,CAAC,sCAAyB,CAAC,CAAC;SAC3C;QACD,KAAK,MAAM,GAAG,IAAI,cAAc,EAAE;YAChC,IAAI,MAAA,OAAO,CAAC,GAAG,CAAC,0CAAG,sCAAkB,CAAC,EAAE;gBACtC,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC,sCAAkB,CAAC,CAAC;aACzC;SACF;QACD,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YAClB,OAAO,gBAAgB,CAAC,MAAM,EAAE,CAAC;SAClC;QACD,MAAM,SAAS,GAAG,eAAe,EAAE,CAAC;QACpC,MAAM,wBAAwB,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;QAC1E,IAAI,IAAI,CAAC,8BAA8B,CAAC,wBAAwB,CAAC,EAAE;YACjE,SAAS,CAAC,SAAS,GAAG,wBAAwB,CAAC,OAAO,CAAC;YACvD,SAAS,CAAC,OAAO,GAAG,wBAAwB,CAAC,OAAO,CAAC;SACtD;aAAM;YACL,SAAS,CAAC,SAAS,GAAG,wBAAwB,CAAC;SAChD;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;IAED;;;;OAIG;IACI,MAAM,CAAC,KAAK,CAAC,QAA2B;QAC7C,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC3B,CAAC;IAEO,MAAM,CAAC,8BAA8B,CAC3C,oBAA6D;QAE7D,OAAO,IAAA,uBAAQ,EAAC,oBAAoB,CAAC,CAAC;IACxC,CAAC;CACF;AAzDD,4CAyDC","sourcesContent":["import { isObject } from '@nestjs/common/utils/shared.utils';\nimport { ContextId, HostComponentInfo } from '../injector/instance-wrapper';\nimport { REQUEST_CONTEXT_ID } from '../router/request/request-constants';\n\nexport function createContextId(): ContextId {\n  /**\n   * We are generating random identifier to track asynchronous\n   * execution context. An identifier does not have to be neither unique\n   * nor unpredictable because WeakMap uses objects as keys (reference comparison).\n   * Thus, even though identifier number might be equal, WeakMap would properly\n   * associate asynchronous context with its internal map values using object reference.\n   * Object is automatically removed once request has been processed (closure).\n   */\n  return { id: Math.random() };\n}\n\nexport type ContextIdResolverFn = (info: HostComponentInfo) => ContextId;\n\nexport interface ContextIdResolver {\n  /**\n   * Payload associated with the custom context id\n   */\n  payload: unknown;\n  /**\n   * A context id resolver function\n   */\n  resolve: ContextIdResolverFn;\n}\n\nexport interface ContextIdStrategy<T = any> {\n  /**\n   * Allows to attach a parent context id to the existing child context id.\n   * This lets you construct durable DI sub-trees that can be shared between contexts.\n   * @param contextId auto-generated child context id\n   * @param request request object\n   */\n  attach(\n    contextId: ContextId,\n    request: T,\n  ): ContextIdResolverFn | ContextIdResolver | undefined;\n}\n\nexport class ContextIdFactory {\n  private static strategy?: ContextIdStrategy;\n\n  /**\n   * Generates a context identifier based on the request object.\n   */\n  public static create(): ContextId {\n    return createContextId();\n  }\n\n  /**\n   * Generates a random identifier to track asynchronous execution context.\n   * @param request request object\n   */\n  public static getByRequest<T extends Record<any, any> = any>(\n    request: T,\n    propsToInspect: string[] = ['raw'],\n  ): ContextId {\n    if (!request) {\n      return ContextIdFactory.create();\n    }\n    if (request[REQUEST_CONTEXT_ID as any]) {\n      return request[REQUEST_CONTEXT_ID as any];\n    }\n    for (const key of propsToInspect) {\n      if (request[key]?.[REQUEST_CONTEXT_ID]) {\n        return request[key][REQUEST_CONTEXT_ID];\n      }\n    }\n    if (!this.strategy) {\n      return ContextIdFactory.create();\n    }\n    const contextId = createContextId();\n    const resolverObjectOrFunction = this.strategy.attach(contextId, request);\n    if (this.isContextIdResolverWithPayload(resolverObjectOrFunction)) {\n      contextId.getParent = resolverObjectOrFunction.resolve;\n      contextId.payload = resolverObjectOrFunction.payload;\n    } else {\n      contextId.getParent = resolverObjectOrFunction;\n    }\n    return contextId;\n  }\n\n  /**\n   * Registers a custom context id strategy that lets you attach\n   * a parent context id to the existing context id object.\n   * @param strategy strategy instance\n   */\n  public static apply(strategy: ContextIdStrategy) {\n    this.strategy = strategy;\n  }\n\n  private static isContextIdResolverWithPayload(\n    resolverOrResolverFn: ContextIdResolver | ContextIdResolverFn,\n  ): resolverOrResolverFn is ContextIdResolver {\n    return isObject(resolverOrResolverFn);\n  }\n}\n"]}