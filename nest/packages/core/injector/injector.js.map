{"version":3,"file":"injector.js","sourceRoot":"/Users/hanxiaoxue/Documents/work/frontEndDebugger/nest/packages/core/","sources":["injector/injector.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  InjectionToken,\n  Logger,\n  LoggerService,\n  OptionalFactoryDependency,\n} from '@nestjs/common';\nimport {\n  OPTIONAL_DEPS_METADATA,\n  OPTIONAL_PROPERTY_DEPS_METADATA,\n  PARAMTYPES_METADATA,\n  PROPERTY_DEPS_METADATA,\n  SELF_DECLARED_DEPS_METADATA,\n} from '@nestjs/common/constants';\nimport { Controller, Injectable, Type } from '@nestjs/common/interfaces';\nimport { clc } from '@nestjs/common/utils/cli-colors.util';\nimport {\n  isFunction,\n  isNil,\n  isObject,\n  isString,\n  isSymbol,\n  isUndefined,\n} from '@nestjs/common/utils/shared.utils';\nimport { iterate } from 'iterare';\nimport { performance } from 'perf_hooks';\nimport { RuntimeException } from '../errors/exceptions/runtime.exception';\nimport { UndefinedDependencyException } from '../errors/exceptions/undefined-dependency.exception';\nimport { UnknownDependenciesException } from '../errors/exceptions/unknown-dependencies.exception';\nimport { STATIC_CONTEXT } from './constants';\nimport { INQUIRER } from './inquirer';\nimport {\n  ContextId,\n  InstancePerContext,\n  InstanceWrapper,\n  PropertyMetadata,\n} from './instance-wrapper';\nimport { InstanceToken, Module } from './module';\n\n/**\n * The type of an injectable dependency\n */\nexport type InjectorDependency = InjectionToken;\n\n/**\n * The property-based dependency\n */\nexport interface PropertyDependency {\n  key: symbol | string;\n  name: InjectorDependency;\n  isOptional?: boolean;\n  instance?: any;\n}\n\n/**\n * Context of a dependency which gets injected by\n * the injector\n */\nexport interface InjectorDependencyContext {\n  /**\n   * The name of the property key (property-based injection)\n   */\n  key?: string | symbol;\n  /**\n   * The function itself, the name of the function, or injection token.\n   */\n  name?: Function | string | symbol;\n  /**\n   * The index of the dependency which gets injected\n   * from the dependencies array\n   */\n  index?: number;\n  /**\n   * The dependency array which gets injected\n   */\n  dependencies?: InjectorDependency[];\n}\n\nexport class Injector {\n  private logger: LoggerService = new Logger('InjectorLogger');\n\n  constructor(private readonly options?: { preview: boolean }) {}\n\n  public loadPrototype<T>(\n    { token }: InstanceWrapper<T>,\n    collection: Map<InstanceToken, InstanceWrapper<T>>,\n    contextId = STATIC_CONTEXT,\n  ) {\n    if (!collection) {\n      return;\n    }\n    const target = collection.get(token);\n    const instance = target.createPrototype(contextId);\n    if (instance) {\n      const wrapper = new InstanceWrapper({\n        ...target,\n        instance,\n      });\n      collection.set(token, wrapper);\n    }\n  }\n\n  public async loadInstance<T>(\n    wrapper: InstanceWrapper<T>,\n    collection: Map<InstanceToken, InstanceWrapper>,\n    moduleRef: Module,\n    contextId = STATIC_CONTEXT,\n    inquirer?: InstanceWrapper,\n  ) {\n    const inquirerId = this.getInquirerId(inquirer);\n    const instanceHost = wrapper.getInstanceByContextId(\n      this.getContextId(contextId, wrapper),\n      inquirerId,\n    );\n    if (instanceHost.isPending) {\n      return instanceHost.donePromise.then((err?: unknown) => {\n        if (err) {\n          throw err;\n        }\n      });\n    }\n    const done = this.applyDoneHook(instanceHost);\n    const token = wrapper.token || wrapper.name;\n\n    const { inject } = wrapper;\n    const targetWrapper = collection.get(token);\n    if (isUndefined(targetWrapper)) {\n      throw new RuntimeException();\n    }\n    if (instanceHost.isResolved) {\n      return done();\n    }\n    try {\n      const t0 = this.getNowTimestamp();\n      const callback = async (instances: unknown[]) => {\n        const properties = await this.resolveProperties(\n          wrapper,\n          moduleRef,\n          inject as InjectionToken[],\n          contextId,\n          wrapper,\n          inquirer,\n        );\n        const instance = await this.instantiateClass(\n          instances,\n          wrapper,\n          targetWrapper,\n          contextId,\n          inquirer,\n        );\n        this.applyProperties(instance, properties);\n        wrapper.initTime = this.getNowTimestamp() - t0;\n        done();\n      };\n      await this.resolveConstructorParams<T>(\n        wrapper,\n        moduleRef,\n        inject as InjectionToken[],\n        callback,\n        contextId,\n        wrapper,\n        inquirer,\n      );\n    } catch (err) {\n      done(err);\n      throw err;\n    }\n  }\n\n  public async loadMiddleware(\n    wrapper: InstanceWrapper,\n    collection: Map<InstanceToken, InstanceWrapper>,\n    moduleRef: Module,\n    contextId = STATIC_CONTEXT,\n    inquirer?: InstanceWrapper,\n  ) {\n    const { metatype, token } = wrapper;\n    const targetWrapper = collection.get(token);\n    if (!isUndefined(targetWrapper.instance)) {\n      return;\n    }\n    targetWrapper.instance = Object.create(metatype.prototype);\n    await this.loadInstance(\n      wrapper,\n      collection,\n      moduleRef,\n      contextId,\n      inquirer || wrapper,\n    );\n  }\n\n  public async loadController(\n    wrapper: InstanceWrapper<Controller>,\n    moduleRef: Module,\n    contextId = STATIC_CONTEXT,\n  ) {\n    const controllers = moduleRef.controllers;\n    await this.loadInstance<Controller>(\n      wrapper,\n      controllers,\n      moduleRef,\n      contextId,\n      wrapper,\n    );\n    await this.loadEnhancersPerContext(wrapper, contextId, wrapper);\n  }\n\n  public async loadInjectable<T = any>(\n    wrapper: InstanceWrapper<T>,\n    moduleRef: Module,\n    contextId = STATIC_CONTEXT,\n    inquirer?: InstanceWrapper,\n  ) {\n    const injectables = moduleRef.injectables;\n    await this.loadInstance<T>(\n      wrapper,\n      injectables,\n      moduleRef,\n      contextId,\n      inquirer,\n    );\n  }\n\n  public async loadProvider(\n    wrapper: InstanceWrapper<Injectable>,\n    moduleRef: Module,\n    contextId = STATIC_CONTEXT,\n    inquirer?: InstanceWrapper,\n  ) {\n    const providers = moduleRef.providers;\n    await this.loadInstance<Injectable>(\n      wrapper,\n      providers,\n      moduleRef,\n      contextId,\n      inquirer,\n    );\n    await this.loadEnhancersPerContext(wrapper, contextId, wrapper);\n  }\n\n  public applyDoneHook<T>(\n    wrapper: InstancePerContext<T>,\n  ): (err?: unknown) => void {\n    let done: (err?: unknown) => void;\n    wrapper.donePromise = new Promise<unknown>((resolve, reject) => {\n      done = resolve;\n    });\n    wrapper.isPending = true;\n    return done;\n  }\n\n  public async resolveConstructorParams<T>(\n    wrapper: InstanceWrapper<T>,\n    moduleRef: Module,\n    inject: InjectorDependency[],\n    callback: (args: unknown[]) => void | Promise<void>,\n    contextId = STATIC_CONTEXT,\n    inquirer?: InstanceWrapper,\n    parentInquirer?: InstanceWrapper,\n  ) {\n    let inquirerId = this.getInquirerId(inquirer);\n    const metadata = wrapper.getCtorMetadata();\n\n    if (metadata && contextId !== STATIC_CONTEXT) {\n      const deps = await this.loadCtorMetadata(\n        metadata,\n        contextId,\n        inquirer,\n        parentInquirer,\n      );\n      return callback(deps);\n    }\n\n    const isFactoryProvider = !isNil(inject);\n    const [dependencies, optionalDependenciesIds] = isFactoryProvider\n      ? this.getFactoryProviderDependencies(wrapper)\n      : this.getClassDependencies(wrapper);\n\n    let isResolved = true;\n    const resolveParam = async (param: unknown, index: number) => {\n      try {\n        if (this.isInquirer(param, parentInquirer)) {\n          return parentInquirer && parentInquirer.instance;\n        }\n        if (inquirer?.isTransient && parentInquirer) {\n          inquirer = parentInquirer;\n          inquirerId = this.getInquirerId(parentInquirer);\n        }\n        const paramWrapper = await this.resolveSingleParam<T>(\n          wrapper,\n          param,\n          { index, dependencies },\n          moduleRef,\n          contextId,\n          inquirer,\n          index,\n        );\n        const instanceHost = paramWrapper.getInstanceByContextId(\n          this.getContextId(contextId, paramWrapper),\n          inquirerId,\n        );\n        if (!instanceHost.isResolved && !paramWrapper.forwardRef) {\n          isResolved = false;\n        }\n        return instanceHost?.instance;\n      } catch (err) {\n        const isOptional = optionalDependenciesIds.includes(index);\n        if (!isOptional) {\n          throw err;\n        }\n        return undefined;\n      }\n    };\n    const instances = await Promise.all(dependencies.map(resolveParam));\n    isResolved && (await callback(instances));\n  }\n\n  public getClassDependencies<T>(\n    wrapper: InstanceWrapper<T>,\n  ): [InjectorDependency[], number[]] {\n    const ctorRef = wrapper.metatype as Type<any>;\n    return [\n      this.reflectConstructorParams(ctorRef),\n      this.reflectOptionalParams(ctorRef),\n    ];\n  }\n\n  public getFactoryProviderDependencies<T>(\n    wrapper: InstanceWrapper<T>,\n  ): [InjectorDependency[], number[]] {\n    const optionalDependenciesIds = [];\n    const isOptionalFactoryDep = (\n      item: InjectionToken | OptionalFactoryDependency,\n    ): item is OptionalFactoryDependency =>\n      !isUndefined((item as OptionalFactoryDependency).token) &&\n      !isUndefined((item as OptionalFactoryDependency).optional);\n\n    const mapFactoryProviderInjectArray = (\n      item: InjectionToken | OptionalFactoryDependency,\n      index: number,\n    ): InjectionToken => {\n      if (typeof item !== 'object') {\n        return item;\n      }\n      if (isOptionalFactoryDep(item)) {\n        if (item.optional) {\n          optionalDependenciesIds.push(index);\n        }\n        return item?.token;\n      }\n      return item;\n    };\n    return [\n      wrapper.inject?.map?.(mapFactoryProviderInjectArray),\n      optionalDependenciesIds,\n    ];\n  }\n\n  public reflectConstructorParams<T>(type: Type<T>): any[] {\n    const paramtypes = [\n      ...(Reflect.getMetadata(PARAMTYPES_METADATA, type) || []),\n    ];\n    const selfParams = this.reflectSelfParams<T>(type);\n\n    selfParams.forEach(({ index, param }) => (paramtypes[index] = param));\n    return paramtypes;\n  }\n\n  public reflectOptionalParams<T>(type: Type<T>): any[] {\n    return Reflect.getMetadata(OPTIONAL_DEPS_METADATA, type) || [];\n  }\n\n  public reflectSelfParams<T>(type: Type<T>): any[] {\n    return Reflect.getMetadata(SELF_DECLARED_DEPS_METADATA, type) || [];\n  }\n\n  public async resolveSingleParam<T>(\n    wrapper: InstanceWrapper<T>,\n    param: Type<any> | string | symbol | any,\n    dependencyContext: InjectorDependencyContext,\n    moduleRef: Module,\n    contextId = STATIC_CONTEXT,\n    inquirer?: InstanceWrapper,\n    keyOrIndex?: symbol | string | number,\n  ) {\n    if (isUndefined(param)) {\n      this.logger.log(\n        'Nest encountered an undefined dependency. This may be due to a circular import or a missing dependency declaration.',\n      );\n      throw new UndefinedDependencyException(\n        wrapper.name,\n        dependencyContext,\n        moduleRef,\n      );\n    }\n    const token = this.resolveParamToken(wrapper, param);\n    return this.resolveComponentInstance<T>(\n      moduleRef,\n      token,\n      dependencyContext,\n      wrapper,\n      contextId,\n      inquirer,\n      keyOrIndex,\n    );\n  }\n\n  public resolveParamToken<T>(\n    wrapper: InstanceWrapper<T>,\n    param: Type<any> | string | symbol | any,\n  ) {\n    if (!param.forwardRef) {\n      return param;\n    }\n    wrapper.forwardRef = true;\n    return param.forwardRef();\n  }\n\n  public async resolveComponentInstance<T>(\n    moduleRef: Module,\n    token: InstanceToken,\n    dependencyContext: InjectorDependencyContext,\n    wrapper: InstanceWrapper<T>,\n    contextId = STATIC_CONTEXT,\n    inquirer?: InstanceWrapper,\n    keyOrIndex?: symbol | string | number,\n  ): Promise<InstanceWrapper> {\n    this.printResolvingDependenciesLog(token, inquirer);\n    this.printLookingForProviderLog(token, moduleRef);\n    const providers = moduleRef.providers;\n    const instanceWrapper = await this.lookupComponent(\n      providers,\n      moduleRef,\n      { ...dependencyContext, name: token },\n      wrapper,\n      contextId,\n      inquirer,\n      keyOrIndex,\n    );\n\n    return this.resolveComponentHost(\n      moduleRef,\n      instanceWrapper,\n      contextId,\n      inquirer,\n    );\n  }\n\n  public async resolveComponentHost<T>(\n    moduleRef: Module,\n    instanceWrapper: InstanceWrapper<T | Promise<T>>,\n    contextId = STATIC_CONTEXT,\n    inquirer?: InstanceWrapper,\n  ): Promise<InstanceWrapper> {\n    const inquirerId = this.getInquirerId(inquirer);\n    const instanceHost = instanceWrapper.getInstanceByContextId(\n      this.getContextId(contextId, instanceWrapper),\n      inquirerId,\n    );\n    if (!instanceHost.isResolved && !instanceWrapper.forwardRef) {\n      await this.loadProvider(\n        instanceWrapper,\n        instanceWrapper.host ?? moduleRef,\n        contextId,\n        inquirer,\n      );\n    } else if (\n      !instanceHost.isResolved &&\n      instanceWrapper.forwardRef &&\n      (contextId !== STATIC_CONTEXT || !!inquirerId)\n    ) {\n      /**\n       * When circular dependency has been detected between\n       * either request/transient providers, we have to asynchronously\n       * resolve instance host for a specific contextId or inquirer, to ensure\n       * that eventual lazily created instance will be merged with the prototype\n       * instantiated beforehand.\n       */\n      instanceHost.donePromise &&\n        instanceHost.donePromise.then(() =>\n          this.loadProvider(instanceWrapper, moduleRef, contextId, inquirer),\n        );\n    }\n    if (instanceWrapper.async) {\n      const host = instanceWrapper.getInstanceByContextId(\n        this.getContextId(contextId, instanceWrapper),\n        inquirerId,\n      );\n      host.instance = await host.instance;\n      instanceWrapper.setInstanceByContextId(contextId, host, inquirerId);\n    }\n    return instanceWrapper;\n  }\n\n  public async lookupComponent<T = any>(\n    providers: Map<Function | string | symbol, InstanceWrapper>,\n    moduleRef: Module,\n    dependencyContext: InjectorDependencyContext,\n    wrapper: InstanceWrapper<T>,\n    contextId = STATIC_CONTEXT,\n    inquirer?: InstanceWrapper,\n    keyOrIndex?: symbol | string | number,\n  ): Promise<InstanceWrapper<T>> {\n    const token = wrapper.token || wrapper.name;\n    const { name } = dependencyContext;\n    if (wrapper && token === name) {\n      throw new UnknownDependenciesException(\n        wrapper.name,\n        dependencyContext,\n        moduleRef,\n        { id: wrapper.id },\n      );\n    }\n    if (providers.has(name)) {\n      const instanceWrapper = providers.get(name);\n      this.printFoundInModuleLog(name, moduleRef);\n      this.addDependencyMetadata(keyOrIndex, wrapper, instanceWrapper);\n      return instanceWrapper;\n    }\n    return this.lookupComponentInParentModules(\n      dependencyContext,\n      moduleRef,\n      wrapper,\n      contextId,\n      inquirer,\n      keyOrIndex,\n    );\n  }\n\n  public async lookupComponentInParentModules<T = any>(\n    dependencyContext: InjectorDependencyContext,\n    moduleRef: Module,\n    wrapper: InstanceWrapper<T>,\n    contextId = STATIC_CONTEXT,\n    inquirer?: InstanceWrapper,\n    keyOrIndex?: symbol | string | number,\n  ) {\n    const instanceWrapper = await this.lookupComponentInImports(\n      moduleRef,\n      dependencyContext.name,\n      wrapper,\n      [],\n      contextId,\n      inquirer,\n      keyOrIndex,\n    );\n    if (isNil(instanceWrapper)) {\n      throw new UnknownDependenciesException(\n        wrapper.name,\n        dependencyContext,\n        moduleRef,\n        { id: wrapper.id },\n      );\n    }\n    return instanceWrapper;\n  }\n\n  public async lookupComponentInImports(\n    moduleRef: Module,\n    name: InstanceToken,\n    wrapper: InstanceWrapper,\n    moduleRegistry: any[] = [],\n    contextId = STATIC_CONTEXT,\n    inquirer?: InstanceWrapper,\n    keyOrIndex?: symbol | string | number,\n    isTraversing?: boolean,\n  ): Promise<any> {\n    let instanceWrapperRef: InstanceWrapper = null;\n    const imports = moduleRef.imports || new Set<Module>();\n    const identity = (item: any) => item;\n\n    let children = [...imports.values()].filter(identity);\n    if (isTraversing) {\n      const contextModuleExports = moduleRef.exports;\n      children = children.filter(child =>\n        contextModuleExports.has(child.metatype),\n      );\n    }\n    for (const relatedModule of children) {\n      if (moduleRegistry.includes(relatedModule.id)) {\n        continue;\n      }\n      this.printLookingForProviderLog(name, relatedModule);\n      moduleRegistry.push(relatedModule.id);\n      const { providers, exports } = relatedModule;\n      if (!exports.has(name) || !providers.has(name)) {\n        const instanceRef = await this.lookupComponentInImports(\n          relatedModule,\n          name,\n          wrapper,\n          moduleRegistry,\n          contextId,\n          inquirer,\n          keyOrIndex,\n          true,\n        );\n        if (instanceRef) {\n          this.addDependencyMetadata(keyOrIndex, wrapper, instanceRef);\n          return instanceRef;\n        }\n        continue;\n      }\n      this.printFoundInModuleLog(name, relatedModule);\n      instanceWrapperRef = providers.get(name);\n      this.addDependencyMetadata(keyOrIndex, wrapper, instanceWrapperRef);\n\n      const inquirerId = this.getInquirerId(inquirer);\n      const instanceHost = instanceWrapperRef.getInstanceByContextId(\n        this.getContextId(contextId, instanceWrapperRef),\n        inquirerId,\n      );\n      if (!instanceHost.isResolved && !instanceWrapperRef.forwardRef) {\n        await this.loadProvider(\n          instanceWrapperRef,\n          relatedModule,\n          contextId,\n          wrapper,\n        );\n        break;\n      }\n    }\n    return instanceWrapperRef;\n  }\n\n  public async resolveProperties<T>(\n    wrapper: InstanceWrapper<T>,\n    moduleRef: Module,\n    inject?: InjectorDependency[],\n    contextId = STATIC_CONTEXT,\n    inquirer?: InstanceWrapper,\n    parentInquirer?: InstanceWrapper,\n  ): Promise<PropertyDependency[]> {\n    if (!isNil(inject)) {\n      return [];\n    }\n    const metadata = wrapper.getPropertiesMetadata();\n    if (metadata && contextId !== STATIC_CONTEXT) {\n      return this.loadPropertiesMetadata(metadata, contextId, inquirer);\n    }\n    const properties = this.reflectProperties(wrapper.metatype as Type<any>);\n    const instances = await Promise.all(\n      properties.map(async (item: PropertyDependency) => {\n        try {\n          const dependencyContext = {\n            key: item.key,\n            name: item.name as Function | string | symbol,\n          };\n          if (this.isInquirer(item.name, parentInquirer)) {\n            return parentInquirer && parentInquirer.instance;\n          }\n          const paramWrapper = await this.resolveSingleParam<T>(\n            wrapper,\n            item.name,\n            dependencyContext,\n            moduleRef,\n            contextId,\n            inquirer,\n            item.key,\n          );\n          if (!paramWrapper) {\n            return undefined;\n          }\n          const inquirerId = this.getInquirerId(inquirer);\n          const instanceHost = paramWrapper.getInstanceByContextId(\n            this.getContextId(contextId, paramWrapper),\n            inquirerId,\n          );\n          return instanceHost.instance;\n        } catch (err) {\n          if (!item.isOptional) {\n            throw err;\n          }\n          return undefined;\n        }\n      }),\n    );\n    return properties.map((item: PropertyDependency, index: number) => ({\n      ...item,\n      instance: instances[index],\n    }));\n  }\n\n  public reflectProperties<T>(type: Type<T>): PropertyDependency[] {\n    const properties = Reflect.getMetadata(PROPERTY_DEPS_METADATA, type) || [];\n    const optionalKeys: string[] =\n      Reflect.getMetadata(OPTIONAL_PROPERTY_DEPS_METADATA, type) || [];\n\n    return properties.map((item: any) => ({\n      ...item,\n      name: item.type,\n      isOptional: optionalKeys.includes(item.key),\n    }));\n  }\n\n  public applyProperties<T = any>(\n    instance: T,\n    properties: PropertyDependency[],\n  ): void {\n    if (!isObject(instance)) {\n      return undefined;\n    }\n    iterate(properties)\n      .filter(item => !isNil(item.instance))\n      .forEach(item => (instance[item.key] = item.instance));\n  }\n\n  public async instantiateClass<T = any>(\n    instances: any[],\n    wrapper: InstanceWrapper,\n    targetMetatype: InstanceWrapper,\n    contextId = STATIC_CONTEXT,\n    inquirer?: InstanceWrapper,\n  ): Promise<T> {\n    const { metatype, inject } = wrapper;\n    const inquirerId = this.getInquirerId(inquirer);\n    const instanceHost = targetMetatype.getInstanceByContextId(\n      this.getContextId(contextId, targetMetatype),\n      inquirerId,\n    );\n    const isInContext =\n      wrapper.isStatic(contextId, inquirer) ||\n      wrapper.isInRequestScope(contextId, inquirer) ||\n      wrapper.isLazyTransient(contextId, inquirer) ||\n      wrapper.isExplicitlyRequested(contextId, inquirer);\n\n    if (this.options?.preview && !wrapper.host?.initOnPreview) {\n      instanceHost.isResolved = true;\n      return instanceHost.instance;\n    }\n\n    if (isNil(inject) && isInContext) {\n      instanceHost.instance = wrapper.forwardRef\n        ? Object.assign(\n            instanceHost.instance,\n            new (metatype as Type<any>)(...instances),\n          )\n        : new (metatype as Type<any>)(...instances);\n    } else if (isInContext) {\n      const factoryReturnValue = (targetMetatype.metatype as any as Function)(\n        ...instances,\n      );\n      instanceHost.instance = await factoryReturnValue;\n    }\n    instanceHost.isResolved = true;\n    return instanceHost.instance;\n  }\n\n  public async loadPerContext<T = any>(\n    instance: T,\n    moduleRef: Module,\n    collection: Map<InstanceToken, InstanceWrapper>,\n    ctx: ContextId,\n    wrapper?: InstanceWrapper,\n  ): Promise<T> {\n    if (!wrapper) {\n      const injectionToken = instance.constructor;\n      wrapper = collection.get(injectionToken);\n    }\n    await this.loadInstance(wrapper, collection, moduleRef, ctx, wrapper);\n    await this.loadEnhancersPerContext(wrapper, ctx, wrapper);\n\n    const host = wrapper.getInstanceByContextId(\n      this.getContextId(ctx, wrapper),\n      wrapper.id,\n    );\n    return host && (host.instance as T);\n  }\n\n  public async loadEnhancersPerContext(\n    wrapper: InstanceWrapper,\n    ctx: ContextId,\n    inquirer?: InstanceWrapper,\n  ) {\n    const enhancers = wrapper.getEnhancersMetadata() || [];\n    const loadEnhancer = (item: InstanceWrapper) => {\n      const hostModule = item.host;\n      return this.loadInstance(\n        item,\n        hostModule.injectables,\n        hostModule,\n        ctx,\n        inquirer,\n      );\n    };\n    await Promise.all(enhancers.map(loadEnhancer));\n  }\n\n  public async loadCtorMetadata(\n    metadata: InstanceWrapper<any>[],\n    contextId: ContextId,\n    inquirer?: InstanceWrapper,\n    parentInquirer?: InstanceWrapper,\n  ): Promise<any[]> {\n    const hosts: Array<InstanceWrapper<any> | undefined> = await Promise.all(\n      metadata.map(async item =>\n        this.resolveScopedComponentHost(\n          item,\n          contextId,\n          inquirer,\n          parentInquirer,\n        ),\n      ),\n    );\n    const inquirerId = this.getInquirerId(inquirer);\n    return hosts.map(\n      item =>\n        item?.getInstanceByContextId(\n          this.getContextId(contextId, item),\n          inquirerId,\n        ).instance,\n    );\n  }\n\n  public async loadPropertiesMetadata(\n    metadata: PropertyMetadata[],\n    contextId: ContextId,\n    inquirer?: InstanceWrapper,\n  ): Promise<PropertyDependency[]> {\n    const dependenciesHosts = await Promise.all(\n      metadata.map(async ({ wrapper: item, key }) => ({\n        key,\n        host: await this.resolveComponentHost(\n          item.host,\n          item,\n          contextId,\n          inquirer,\n        ),\n      })),\n    );\n    const inquirerId = this.getInquirerId(inquirer);\n    return dependenciesHosts.map(({ key, host }) => ({\n      key,\n      name: key,\n      instance: host.getInstanceByContextId(\n        this.getContextId(contextId, host),\n        inquirerId,\n      ).instance,\n    }));\n  }\n\n  private getInquirerId(inquirer: InstanceWrapper | undefined): string {\n    return inquirer && inquirer.id;\n  }\n\n  private resolveScopedComponentHost(\n    item: InstanceWrapper,\n    contextId: ContextId,\n    inquirer?: InstanceWrapper,\n    parentInquirer?: InstanceWrapper,\n  ) {\n    return this.isInquirerRequest(item, parentInquirer)\n      ? parentInquirer\n      : this.resolveComponentHost(item.host, item, contextId, inquirer);\n  }\n\n  private isInquirerRequest(\n    item: InstanceWrapper,\n    parentInquirer: InstanceWrapper | undefined,\n  ) {\n    return item.isTransient && item.name === INQUIRER && parentInquirer;\n  }\n\n  private isInquirer(\n    param: unknown,\n    parentInquirer: InstanceWrapper | undefined,\n  ) {\n    return param === INQUIRER && parentInquirer;\n  }\n\n  protected addDependencyMetadata(\n    keyOrIndex: symbol | string | number,\n    hostWrapper: InstanceWrapper,\n    instanceWrapper: InstanceWrapper,\n  ) {\n    if (isSymbol(keyOrIndex) || isString(keyOrIndex)) {\n      hostWrapper.addPropertiesMetadata(keyOrIndex, instanceWrapper);\n    } else {\n      hostWrapper.addCtorMetadata(keyOrIndex, instanceWrapper);\n    }\n  }\n\n  private getTokenName(token: InstanceToken): string {\n    return isFunction(token) ? (token as Function).name : token.toString();\n  }\n\n  private printResolvingDependenciesLog(\n    token: InstanceToken,\n    inquirer?: InstanceWrapper,\n  ): void {\n    if (!this.isDebugMode()) {\n      return;\n    }\n    const tokenName = this.getTokenName(token);\n    const dependentName =\n      (inquirer?.name && inquirer.name.toString?.()) ?? 'unknown';\n    const isAlias = dependentName === tokenName;\n\n    const messageToPrint = `Resolving dependency ${clc.cyanBright(\n      tokenName,\n    )}${clc.green(' in the ')}${clc.yellow(dependentName)}${clc.green(\n      ` provider ${isAlias ? '(alias)' : ''}`,\n    )}`;\n\n    this.logger.log(messageToPrint);\n  }\n\n  private printLookingForProviderLog(\n    token: InstanceToken,\n    moduleRef: Module,\n  ): void {\n    if (!this.isDebugMode()) {\n      return;\n    }\n    const tokenName = this.getTokenName(token);\n    const moduleRefName = moduleRef?.metatype?.name ?? 'unknown';\n    this.logger.log(\n      `Looking for ${clc.cyanBright(tokenName)}${clc.green(\n        ' in ',\n      )}${clc.magentaBright(moduleRefName)}`,\n    );\n  }\n\n  private printFoundInModuleLog(token: InstanceToken, moduleRef: Module): void {\n    if (!this.isDebugMode()) {\n      return;\n    }\n    const tokenName = this.getTokenName(token);\n    const moduleRefName = moduleRef?.metatype?.name ?? 'unknown';\n    this.logger.log(\n      `Found ${clc.cyanBright(tokenName)}${clc.green(\n        ' in ',\n      )}${clc.magentaBright(moduleRefName)}`,\n    );\n  }\n\n  private isDebugMode(): boolean {\n    return !!process.env.NEST_DEBUG;\n  }\n\n  private getContextId(\n    contextId: ContextId,\n    instanceWrapper: InstanceWrapper,\n  ): ContextId {\n    return contextId.getParent\n      ? contextId.getParent({\n          token: instanceWrapper.token,\n          isTreeDurable: instanceWrapper.isDependencyTreeDurable(),\n        })\n      : contextId;\n  }\n\n  private getNowTimestamp() {\n    return performance.now();\n  }\n}\n"]}