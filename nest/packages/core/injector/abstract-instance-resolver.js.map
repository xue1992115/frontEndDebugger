{"version":3,"file":"abstract-instance-resolver.js","sourceRoot":"/Users/hanxiaoxue/Documents/work/frontEndDebugger/nest/packages/core/","sources":["injector/abstract-instance-resolver.ts"],"names":[],"mappings":";;;AAAA,2CAAuD;AAEvD,qDAG8B;AAM9B,MAAsB,wBAAwB;IASlC,IAAI,CACZ,WAA8D,EAC9D,OAA8C;QAE9C,MAAM,mBAAmB,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,CACpD,WAAW,EACX,OAAO,CACR,CAAC;QACF,MAAM,aAAa,GAAG,CAAC,EAAE,UAAU,EAAgB,EAAE,EAAE;YACrD,IACE,UAAU,CAAC,KAAK,KAAK,cAAK,CAAC,OAAO;gBAClC,UAAU,CAAC,KAAK,KAAK,cAAK,CAAC,SAAS,EACpC;gBACA,MAAM,IAAI,uCAA0B,CAAC,WAAW,CAAC,CAAC;aACnD;YACD,OAAO,UAAU,CAAC,QAAQ,CAAC;QAC7B,CAAC,CAAC;QACF,IAAI,KAAK,CAAC,OAAO,CAAC,mBAAmB,CAAC,EAAE;YACtC,OAAO,mBAAmB,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;SAC/C;QACD,OAAO,aAAa,CAAC,mBAAmB,CAAC,CAAC;IAC5C,CAAC;IAES,KAAK,CAAC,iBAAiB,CAC/B,WAA8D,EAC9D,aAAqB,EACrB,SAAoB,EACpB,OAA6B;QAE7B,MAAM,mBAAmB,GAAG,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM;YACzC,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,WAAW,EAAE;gBACtC,QAAQ,EAAE,aAAa,CAAC,EAAE;gBAC1B,IAAI,EAAE,OAAO,CAAC,IAAI;aACnB,CAAC;YACJ,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,WAAW,EAAE;gBACtC,IAAI,EAAE,OAAO,CAAC,IAAI;aACnB,CAAC,CAAC;QAEP,MAAM,aAAa,GAAG,KAAK,EAAE,YAA0B,EAAE,EAAE;YACzD,MAAM,EAAE,UAAU,EAAE,UAAU,EAAE,GAAG,YAAY,CAAC;YAChD,IAAI,UAAU,CAAC,sBAAsB,EAAE,IAAI,CAAC,UAAU,CAAC,WAAW,EAAE;gBAClE,OAAO,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,EAAE,MAAM,EAAE,OAAO,CAAC,MAAM,EAAE,CAAC,CAAC;aAC1D;YAED,MAAM,QAAQ,GAAG,UAAU,CAAC,QAAQ,IAAI,EAAE,WAAW,EAAE,WAAW,EAAE,CAAC;YACrE,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,cAAc,CACjD,QAAQ,EACR,UAAU,CAAC,IAAI,EACf,UAAU,EACV,SAAS,EACT,UAAU,CACX,CAAC;YACF,IAAI,CAAC,QAAQ,EAAE;gBACb,MAAM,IAAI,oCAAuB,EAAE,CAAC;aACrC;YACD,OAAO,QAAQ,CAAC;QAClB,CAAC,CAAC;QAEF,IAAI,KAAK,CAAC,OAAO,CAAC,mBAAmB,CAAC,EAAE;YACtC,OAAO,OAAO,CAAC,GAAG,CAChB,mBAAmB,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC,CACrE,CAAC;SACH;QACD,OAAO,aAAa,CAAC,mBAAmB,CAAC,CAAC;IAC5C,CAAC;CACF;AA1ED,4DA0EC","sourcesContent":["import { Abstract, Scope, Type } from '@nestjs/common';\nimport { GetOrResolveOptions } from '@nestjs/common/interfaces';\nimport {\n  InvalidClassScopeException,\n  UnknownElementException,\n} from '../errors/exceptions';\nimport { Injector } from './injector';\nimport { InstanceLink, InstanceLinksHost } from './instance-links-host';\nimport { ContextId } from './instance-wrapper';\nimport { Module } from './module';\n\nexport abstract class AbstractInstanceResolver {\n  protected abstract instanceLinksHost: InstanceLinksHost;\n  protected abstract injector: Injector;\n\n  protected abstract get<TInput = any, TResult = TInput>(\n    typeOrToken: Type<TInput> | Function | string | symbol,\n    options?: GetOrResolveOptions,\n  ): TResult | Array<TResult>;\n\n  protected find<TInput = any, TResult = TInput>(\n    typeOrToken: Type<TInput> | Abstract<TInput> | string | symbol,\n    options: { moduleId?: string; each?: boolean },\n  ): TResult | Array<TResult> {\n    const instanceLinkOrArray = this.instanceLinksHost.get<TResult>(\n      typeOrToken,\n      options,\n    );\n    const pluckInstance = ({ wrapperRef }: InstanceLink) => {\n      if (\n        wrapperRef.scope === Scope.REQUEST ||\n        wrapperRef.scope === Scope.TRANSIENT\n      ) {\n        throw new InvalidClassScopeException(typeOrToken);\n      }\n      return wrapperRef.instance;\n    };\n    if (Array.isArray(instanceLinkOrArray)) {\n      return instanceLinkOrArray.map(pluckInstance);\n    }\n    return pluckInstance(instanceLinkOrArray);\n  }\n\n  protected async resolvePerContext<TInput = any, TResult = TInput>(\n    typeOrToken: Type<TInput> | Abstract<TInput> | string | symbol,\n    contextModule: Module,\n    contextId: ContextId,\n    options?: GetOrResolveOptions,\n  ): Promise<TResult | Array<TResult>> {\n    const instanceLinkOrArray = options?.strict\n      ? this.instanceLinksHost.get(typeOrToken, {\n          moduleId: contextModule.id,\n          each: options.each,\n        })\n      : this.instanceLinksHost.get(typeOrToken, {\n          each: options.each,\n        });\n\n    const pluckInstance = async (instanceLink: InstanceLink) => {\n      const { wrapperRef, collection } = instanceLink;\n      if (wrapperRef.isDependencyTreeStatic() && !wrapperRef.isTransient) {\n        return this.get(typeOrToken, { strict: options.strict });\n      }\n\n      const ctorHost = wrapperRef.instance || { constructor: typeOrToken };\n      const instance = await this.injector.loadPerContext(\n        ctorHost,\n        wrapperRef.host,\n        collection,\n        contextId,\n        wrapperRef,\n      );\n      if (!instance) {\n        throw new UnknownElementException();\n      }\n      return instance;\n    };\n\n    if (Array.isArray(instanceLinkOrArray)) {\n      return Promise.all(\n        instanceLinkOrArray.map(instanceLink => pluckInstance(instanceLink)),\n      );\n    }\n    return pluckInstance(instanceLinkOrArray);\n  }\n}\n"]}