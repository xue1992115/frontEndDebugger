{"version":3,"file":"module-ref.js","sourceRoot":"/Users/hanxiaoxue/Documents/work/frontEndDebugger/nest/packages/core/","sources":["injector/module-ref.ts"],"names":[],"mappings":";;;AAAA,2CAAkE;AAClE,gEAA2D;AAC3D,sDAAkD;AAClD,6EAAwE;AAExE,yCAAsC;AACtC,+DAA0D;AAC1D,yDAAgE;AAiBhE,MAAsB,SAAU,SAAQ,qDAAwB;IAI9D,IAAc,iBAAiB;QAC7B,IAAI,CAAC,IAAI,CAAC,kBAAkB,EAAE;YAC5B,IAAI,CAAC,kBAAkB,GAAG,IAAI,uCAAiB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;SACjE;QACD,OAAO,IAAI,CAAC,kBAAkB,CAAC;IACjC,CAAC;IAED,YAA+B,SAAwB;QACrD,KAAK,EAAE,CAAC;QADqB,cAAS,GAAT,SAAS,CAAe;QAVpC,aAAQ,GAAG,IAAI,mBAAQ,EAAE,CAAC;IAY7C,CAAC;IA+FM,UAAU,CACf,KAAgC;QAEhC,MAAM,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAEzD,IAAI,KAAK,GAAG,cAAK,CAAC,OAAO,CAAC;QAC1B,IAAI,CAAC,UAAU,CAAC,sBAAsB,EAAE,EAAE;YACxC,KAAK,GAAG,cAAK,CAAC,OAAO,CAAC;SACvB;aAAM,IAAI,UAAU,CAAC,WAAW,EAAE;YACjC,KAAK,GAAG,cAAK,CAAC,SAAS,CAAC;SACzB;QACD,OAAO,EAAE,KAAK,EAAE,CAAC;IACnB,CAAC;IAEM,0BAA0B,CAAU,OAAU,EAAE,SAAoB;QACzE,IAAI,CAAC,SAAS,CAAC,uBAAuB,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;IAC7D,CAAC;IAES,KAAK,CAAC,gBAAgB,CAC9B,IAAa,EACb,SAAiB;QAEjB,MAAM,OAAO,GAAG,IAAI,kCAAe,CAAC;YAClC,IAAI,EAAE,IAAI,IAAI,IAAI,CAAC,IAAI;YACvB,QAAQ,EAAE,IAAI;YACd,UAAU,EAAE,KAAK;YACjB,KAAK,EAAE,IAAA,+BAAa,EAAC,IAAI,CAAC;YAC1B,OAAO,EAAE,IAAA,sBAAS,EAAC,IAAI,CAAC;YACxB,IAAI,EAAE,SAAS;SAChB,CAAC,CAAC;QACH,OAAO,IAAI,OAAO,CAAI,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,EAAE;YAC9C,IAAI;gBACF,MAAM,QAAQ,GAAG,KAAK,EAAE,SAAgB,EAAE,EAAE;oBAC1C,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CACtD,OAAO,EACP,SAAS,CACV,CAAC;oBACF,MAAM,QAAQ,GAAG,IAAI,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC;oBACxC,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;oBACpD,OAAO,CAAC,QAAQ,CAAC,CAAC;gBACpB,CAAC,CAAC;gBACF,MAAM,IAAI,CAAC,QAAQ,CAAC,wBAAwB,CAC1C,OAAO,EACP,SAAS,EACT,SAAS,EACT,QAAQ,CACT,CAAC;aACH;YAAC,OAAO,GAAG,EAAE;gBACZ,MAAM,CAAC,GAAG,CAAC,CAAC;aACb;QACH,CAAC,CAAC,CAAC;IACL,CAAC;CACF;AAhKD,8BAgKC","sourcesContent":["import { IntrospectionResult, Scope, Type } from '@nestjs/common';\nimport { getClassScope } from '../helpers/get-class-scope';\nimport { isDurable } from '../helpers/is-durable';\nimport { AbstractInstanceResolver } from './abstract-instance-resolver';\nimport { NestContainer } from './container';\nimport { Injector } from './injector';\nimport { InstanceLinksHost } from './instance-links-host';\nimport { ContextId, InstanceWrapper } from './instance-wrapper';\nimport { Module } from './module';\n\nexport interface ModuleRefGetOrResolveOpts {\n  /**\n   * If enabled, lookup will only be performed in the host module.\n   * @default true\n   */\n  strict?: boolean;\n  /**\n   * If enabled, instead of returning a first instance registered under a given token,\n   * a list of instances will be returned.\n   * @default false\n   */\n  each?: boolean;\n}\n\nexport abstract class ModuleRef extends AbstractInstanceResolver {\n  protected readonly injector = new Injector();\n  private _instanceLinksHost: InstanceLinksHost;\n\n  protected get instanceLinksHost() {\n    if (!this._instanceLinksHost) {\n      this._instanceLinksHost = new InstanceLinksHost(this.container);\n    }\n    return this._instanceLinksHost;\n  }\n\n  constructor(protected readonly container: NestContainer) {\n    super();\n  }\n\n  /**\n   * Retrieves an instance of either injectable or controller, otherwise, throws exception.\n   * @returns {TResult}\n   */\n  abstract get<TInput = any, TResult = TInput>(\n    typeOrToken: Type<TInput> | Function | string | symbol,\n  ): TResult;\n  /**\n   * Retrieves an instance of either injectable or controller, otherwise, throws exception.\n   * @returns {TResult}\n   */\n  abstract get<TInput = any, TResult = TInput>(\n    typeOrToken: Type<TInput> | Function | string | symbol,\n    options: {\n      /**\n       * If enabled, lookup will only be performed in the host module.\n       * @default true\n       */\n      strict?: boolean;\n      /** This indicates that only the first instance registered will be returned. */\n      each?: undefined | false;\n    },\n  ): TResult;\n  /**\n   * Retrieves a list of instances of either injectables or controllers, otherwise, throws exception.\n   * @returns {Array<TResult>}\n   */\n  abstract get<TInput = any, TResult = TInput>(\n    typeOrToken: Type<TInput> | Function | string | symbol,\n    options: {\n      /**\n       * If enabled, lookup will only be performed in the host module.\n       * @default true\n       */\n      strict?: boolean;\n      /** This indicates that a list of instances will be returned. */\n      each: true;\n    },\n  ): Array<TResult>;\n  /**\n   * Retrieves an instance (or a list of instances) of either injectable or controller, otherwise, throws exception.\n   * @returns {TResult | Array<TResult>}\n   */\n  abstract get<TInput = any, TResult = TInput>(\n    typeOrToken: Type<TInput> | Function | string | symbol,\n    options?: ModuleRefGetOrResolveOpts,\n  ): TResult | Array<TResult>;\n\n  /**\n   * Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.\n   * @returns {Array<TResult>}\n   */\n  abstract resolve<TInput = any, TResult = TInput>(\n    typeOrToken: Type<TInput> | Function | string | symbol,\n  ): Promise<TResult>;\n  /**\n   * Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.\n   * @returns {Array<TResult>}\n   */\n  abstract resolve<TInput = any, TResult = TInput>(\n    typeOrToken: Type<TInput> | Function | string | symbol,\n    contextId?: { id: number },\n  ): Promise<TResult>;\n  /**\n   * Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.\n   * @returns {Array<TResult>}\n   */\n  abstract resolve<TInput = any, TResult = TInput>(\n    typeOrToken: Type<TInput> | Function | string | symbol,\n    contextId?: { id: number },\n    options?: { strict?: boolean; each?: undefined | false },\n  ): Promise<TResult>;\n  /**\n   * Resolves transient or request-scoped instances of either injectables or controllers, otherwise, throws exception.\n   * @returns {Array<TResult>}\n   */\n  abstract resolve<TInput = any, TResult = TInput>(\n    typeOrToken: Type<TInput> | Function | string | symbol,\n    contextId?: { id: number },\n    options?: { strict?: boolean; each: true },\n  ): Promise<Array<TResult>>;\n  /**\n   * Resolves transient or request-scoped instance (or a list of instances) of either injectable or controller, otherwise, throws exception.\n   * @returns {Promise<TResult | Array<TResult>>}\n   */\n  abstract resolve<TInput = any, TResult = TInput>(\n    typeOrToken: Type<TInput> | Function | string | symbol,\n    contextId?: { id: number },\n    options?: ModuleRefGetOrResolveOpts,\n  ): Promise<TResult | Array<TResult>>;\n\n  public abstract create<T = any>(type: Type<T>): Promise<T>;\n\n  public introspect<T = any>(\n    token: Type<T> | string | symbol,\n  ): IntrospectionResult {\n    const { wrapperRef } = this.instanceLinksHost.get(token);\n\n    let scope = Scope.DEFAULT;\n    if (!wrapperRef.isDependencyTreeStatic()) {\n      scope = Scope.REQUEST;\n    } else if (wrapperRef.isTransient) {\n      scope = Scope.TRANSIENT;\n    }\n    return { scope };\n  }\n\n  public registerRequestByContextId<T = any>(request: T, contextId: ContextId) {\n    this.container.registerRequestProvider(request, contextId);\n  }\n\n  protected async instantiateClass<T = any>(\n    type: Type<T>,\n    moduleRef: Module,\n  ): Promise<T> {\n    const wrapper = new InstanceWrapper({\n      name: type && type.name,\n      metatype: type,\n      isResolved: false,\n      scope: getClassScope(type),\n      durable: isDurable(type),\n      host: moduleRef,\n    });\n    return new Promise<T>(async (resolve, reject) => {\n      try {\n        const callback = async (instances: any[]) => {\n          const properties = await this.injector.resolveProperties(\n            wrapper,\n            moduleRef,\n          );\n          const instance = new type(...instances);\n          this.injector.applyProperties(instance, properties);\n          resolve(instance);\n        };\n        await this.injector.resolveConstructorParams<T>(\n          wrapper,\n          moduleRef,\n          undefined,\n          callback,\n        );\n      } catch (err) {\n        reject(err);\n      }\n    });\n  }\n}\n"]}