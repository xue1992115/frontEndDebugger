{"version":3,"file":"interceptors-consumer.js","sourceRoot":"/Users/hanxiaoxue/Documents/work/frontEndDebugger/nest/packages/core/","sources":["interceptors/interceptors-consumer.ts"],"names":[],"mappings":";;;AAMA,oEAA4D;AAC5D,+BAA8D;AAC9D,8CAAqD;AACrD,8EAAyE;AAEzE,MAAa,oBAAoB;IACxB,KAAK,CAAC,SAAS,CACpB,YAA+B,EAC/B,IAAe,EACf,QAAoB,EACpB,QAAyC,EACzC,IAA4B,EAC5B,IAAe;QAEf,IAAI,IAAA,sBAAO,EAAC,YAAY,CAAC,EAAE;YACzB,OAAO,IAAI,EAAE,CAAC;SACf;QACD,MAAM,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;QAC7D,OAAO,CAAC,OAAO,CAAW,IAAI,CAAC,CAAC;QAEhC,MAAM,MAAM,GAAG,IAAA,YAAK,EAAC,GAAG,EAAE,CAAC,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC;QACzD,MAAM,MAAM,GACV,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,CACV,KAAK,IAAI,EAAE;YACT,IAAI,CAAC,IAAI,YAAY,CAAC,MAAM,EAAE;gBAC5B,OAAO,MAAM,CAAC;aACf;YACD,MAAM,OAAO,GAAgB;gBAC3B,MAAM,EAAE,GAAG,EAAE,CAAC,IAAA,WAAW,EAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAA,oBAAQ,GAAE,CAAC;aAC5D,CAAC;YACF,OAAO,YAAY,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QACrD,CAAC,CAAC;QACJ,OAAO,MAAM,EAAE,EAAE,CAAC;IACpB,CAAC;IAEM,aAAa,CAClB,IAAe,EACf,QAAoB,EACpB,QAAyC;QAEzC,OAAO,IAAI,6CAAoB,CAC7B,IAAI,EACJ,QAAQ,CAAC,WAA4B,EACrC,QAAQ,CACT,CAAC;IACJ,CAAC;IAEM,iBAAiB,CAAC,IAAwB;QAC/C,OAAO,IAAA,WAAW,EAAC,IAAI,EAAE,CAAC,CAAC,IAAI,CAC7B,IAAA,qBAAS,EAAC,GAAG,CAAC,EAAE;YACd,MAAM,UAAU,GAAG,GAAG,YAAY,OAAO,IAAI,GAAG,YAAY,iBAAU,CAAC;YACvE,OAAO,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACjD,CAAC,CAAC,CACH,CAAC;IACJ,CAAC;CACF;AAlDD,oDAkDC","sourcesContent":["import { NestInterceptor, Type } from '@nestjs/common';\nimport {\n  CallHandler,\n  ContextType,\n  Controller,\n} from '@nestjs/common/interfaces';\nimport { isEmpty } from '@nestjs/common/utils/shared.utils';\nimport { defer, from as fromPromise, Observable } from 'rxjs';\nimport { mergeAll, switchMap } from 'rxjs/operators';\nimport { ExecutionContextHost } from '../helpers/execution-context-host';\n\nexport class InterceptorsConsumer {\n  public async intercept<TContext extends string = ContextType>(\n    interceptors: NestInterceptor[],\n    args: unknown[],\n    instance: Controller,\n    callback: (...args: unknown[]) => unknown,\n    next: () => Promise<unknown>,\n    type?: TContext,\n  ): Promise<unknown> {\n    if (isEmpty(interceptors)) {\n      return next();\n    }\n    const context = this.createContext(args, instance, callback);\n    context.setType<TContext>(type);\n\n    const start$ = defer(() => this.transformDeferred(next));\n    const nextFn =\n      (i = 0) =>\n      async () => {\n        if (i >= interceptors.length) {\n          return start$;\n        }\n        const handler: CallHandler = {\n          handle: () => fromPromise(nextFn(i + 1)()).pipe(mergeAll()),\n        };\n        return interceptors[i].intercept(context, handler);\n      };\n    return nextFn()();\n  }\n\n  public createContext(\n    args: unknown[],\n    instance: Controller,\n    callback: (...args: unknown[]) => unknown,\n  ): ExecutionContextHost {\n    return new ExecutionContextHost(\n      args,\n      instance.constructor as Type<unknown>,\n      callback,\n    );\n  }\n\n  public transformDeferred(next: () => Promise<any>): Observable<any> {\n    return fromPromise(next()).pipe(\n      switchMap(res => {\n        const isDeferred = res instanceof Promise || res instanceof Observable;\n        return isDeferred ? res : Promise.resolve(res);\n      }),\n    );\n  }\n}\n"]}