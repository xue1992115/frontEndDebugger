{"version":3,"file":"testing-injector.js","sourceRoot":"/Users/hanxiaoxue/Documents/work/frontEndDebugger/nest/packages/testing/","sources":["testing-injector.ts"],"names":[],"mappings":";;;AACA,+DAAiE;AACjE,6DAGwC;AACxC,6EAAyE;AAIzE;;GAEG;AACH,MAAa,eAAgB,SAAQ,mBAAQ;IAIpC,SAAS,CAAC,MAAmB;QAClC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;IAEM,YAAY,CAAC,SAAwB;QAC1C,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC7B,CAAC;IAEM,KAAK,CAAC,wBAAwB,CACnC,SAAiB,EACjB,IAAS,EACT,iBAA4C,EAC5C,OAA2B,EAC3B,SAAS,GAAG,0BAAc,EAC1B,QAA0B,EAC1B,UAA4B;QAE5B,IAAI;YACF,MAAM,uBAAuB,GAAG,MAAM,KAAK,CAAC,wBAAwB,CAClE,SAAS,EACT,IAAI,EACJ,iBAAiB,EACjB,OAAO,EACP,SAAS,EACT,QAAQ,EACR,UAAU,CACX,CAAC;YACF,OAAO,uBAAuB,CAAC;SAChC;QAAC,OAAO,GAAG,EAAE;YACZ,IAAI,IAAI,CAAC,MAAM,EAAE;gBACf,MAAM,cAAc,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;gBACzC,IAAI,CAAC,cAAc,EAAE;oBACnB,MAAM,GAAG,CAAC;iBACX;gBACD,MAAM,UAAU,GAAG,IAAI,kCAAe,CAAC;oBACrC,IAAI;oBACJ,OAAO,EAAE,KAAK;oBACd,KAAK,EAAE,OAAO,CAAC,KAAK;oBACpB,QAAQ,EAAE,cAAc;oBACxB,UAAU,EAAE,IAAI;oBAChB,IAAI,EAAE,SAAS;oBACf,QAAQ,EAAE,OAAO,CAAC,QAAQ;iBAC3B,CAAC,CAAC;gBACH,MAAM,kBAAkB,GAAG,IAAI,CAAC,SAAS,CAAC,wBAAwB,EAAE,CAAC;gBACrE,kBAAkB,CAAC,iBAAiB,CAClC;oBACE,OAAO,EAAE,IAAI;oBACb,QAAQ,EAAE,cAAc;iBACzB,EACD,kBAAkB,CAAC,SAAS,CAC7B,CAAC;gBACF,kBAAkB,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;gBAC7C,OAAO,UAAU,CAAC;aACnB;iBAAM;gBACL,MAAM,GAAG,CAAC;aACX;SACF;IACH,CAAC;CACF;AA9DD,0CA8DC","sourcesContent":["import { NestContainer } from '@nestjs/core';\nimport { STATIC_CONTEXT } from '@nestjs/core/injector/constants';\nimport {\n  Injector,\n  InjectorDependencyContext,\n} from '@nestjs/core/injector/injector';\nimport { InstanceWrapper } from '@nestjs/core/injector/instance-wrapper';\nimport { Module } from '@nestjs/core/injector/module';\nimport { MockFactory } from './interfaces';\n\n/**\n * @publicApi\n */\nexport class TestingInjector extends Injector {\n  protected mocker?: MockFactory;\n  protected container: NestContainer;\n\n  public setMocker(mocker: MockFactory) {\n    this.mocker = mocker;\n  }\n\n  public setContainer(container: NestContainer) {\n    this.container = container;\n  }\n\n  public async resolveComponentInstance<T>(\n    moduleRef: Module,\n    name: any,\n    dependencyContext: InjectorDependencyContext,\n    wrapper: InstanceWrapper<T>,\n    contextId = STATIC_CONTEXT,\n    inquirer?: InstanceWrapper,\n    keyOrIndex?: string | number,\n  ): Promise<InstanceWrapper> {\n    try {\n      const existingProviderWrapper = await super.resolveComponentInstance(\n        moduleRef,\n        name,\n        dependencyContext,\n        wrapper,\n        contextId,\n        inquirer,\n        keyOrIndex,\n      );\n      return existingProviderWrapper;\n    } catch (err) {\n      if (this.mocker) {\n        const mockedInstance = this.mocker(name);\n        if (!mockedInstance) {\n          throw err;\n        }\n        const newWrapper = new InstanceWrapper({\n          name,\n          isAlias: false,\n          scope: wrapper.scope,\n          instance: mockedInstance,\n          isResolved: true,\n          host: moduleRef,\n          metatype: wrapper.metatype,\n        });\n        const internalCoreModule = this.container.getInternalCoreModuleRef();\n        internalCoreModule.addCustomProvider(\n          {\n            provide: name,\n            useValue: mockedInstance,\n          },\n          internalCoreModule.providers,\n        );\n        internalCoreModule.addExportedProvider(name);\n        return newWrapper;\n      } else {\n        throw err;\n      }\n    }\n  }\n}\n"]}